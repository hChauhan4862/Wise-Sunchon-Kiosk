// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newVariSeatFix(db *gorm.DB, opts ...gen.DOOption) variSeatFix {
	_variSeatFix := variSeatFix{}

	_variSeatFix.variSeatFixDo.UseDB(db, opts...)
	_variSeatFix.variSeatFixDo.UseModel(&model.VariSeatFix{})

	tableName := _variSeatFix.variSeatFixDo.TableName()
	_variSeatFix.ALL = field.NewAsterisk(tableName)
	_variSeatFix.ExamGubun = field.NewString(tableName, "exam_gubun")
	_variSeatFix.RoomNo = field.NewInt64(tableName, "room_no")
	_variSeatFix.StartDate = field.NewString(tableName, "start_date")
	_variSeatFix.StartTime = field.NewString(tableName, "start_time")
	_variSeatFix.EndDate = field.NewString(tableName, "end_date")
	_variSeatFix.EndTime = field.NewString(tableName, "end_time")
	_variSeatFix.SeatFix = field.NewString(tableName, "seat_fix")
	_variSeatFix.OriSeatFix = field.NewString(tableName, "ori_seat_fix")
	_variSeatFix.RegDate = field.NewString(tableName, "reg_date")
	_variSeatFix.SeatRoomSeatFix = field.NewString(tableName, "seat_room_seat_fix")

	_variSeatFix.fillFieldMap()

	return _variSeatFix
}

type variSeatFix struct {
	variSeatFixDo

	ALL             field.Asterisk
	ExamGubun       field.String
	RoomNo          field.Int64
	StartDate       field.String
	StartTime       field.String
	EndDate         field.String
	EndTime         field.String
	SeatFix         field.String
	OriSeatFix      field.String
	RegDate         field.String
	SeatRoomSeatFix field.String

	fieldMap map[string]field.Expr
}

func (v variSeatFix) Table(newTableName string) *variSeatFix {
	v.variSeatFixDo.UseTable(newTableName)
	return v.updateTableName(newTableName)
}

func (v variSeatFix) As(alias string) *variSeatFix {
	v.variSeatFixDo.DO = *(v.variSeatFixDo.As(alias).(*gen.DO))
	return v.updateTableName(alias)
}

func (v *variSeatFix) updateTableName(table string) *variSeatFix {
	v.ALL = field.NewAsterisk(table)
	v.ExamGubun = field.NewString(table, "exam_gubun")
	v.RoomNo = field.NewInt64(table, "room_no")
	v.StartDate = field.NewString(table, "start_date")
	v.StartTime = field.NewString(table, "start_time")
	v.EndDate = field.NewString(table, "end_date")
	v.EndTime = field.NewString(table, "end_time")
	v.SeatFix = field.NewString(table, "seat_fix")
	v.OriSeatFix = field.NewString(table, "ori_seat_fix")
	v.RegDate = field.NewString(table, "reg_date")
	v.SeatRoomSeatFix = field.NewString(table, "seat_room_seat_fix")

	v.fillFieldMap()

	return v
}

func (v *variSeatFix) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := v.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (v *variSeatFix) fillFieldMap() {
	v.fieldMap = make(map[string]field.Expr, 10)
	v.fieldMap["exam_gubun"] = v.ExamGubun
	v.fieldMap["room_no"] = v.RoomNo
	v.fieldMap["start_date"] = v.StartDate
	v.fieldMap["start_time"] = v.StartTime
	v.fieldMap["end_date"] = v.EndDate
	v.fieldMap["end_time"] = v.EndTime
	v.fieldMap["seat_fix"] = v.SeatFix
	v.fieldMap["ori_seat_fix"] = v.OriSeatFix
	v.fieldMap["reg_date"] = v.RegDate
	v.fieldMap["seat_room_seat_fix"] = v.SeatRoomSeatFix
}

func (v variSeatFix) clone(db *gorm.DB) variSeatFix {
	v.variSeatFixDo.ReplaceConnPool(db.Statement.ConnPool)
	return v
}

func (v variSeatFix) replaceDB(db *gorm.DB) variSeatFix {
	v.variSeatFixDo.ReplaceDB(db)
	return v
}

type variSeatFixDo struct{ gen.DO }

type IVariSeatFixDo interface {
	gen.SubQuery
	Debug() IVariSeatFixDo
	WithContext(ctx context.Context) IVariSeatFixDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IVariSeatFixDo
	WriteDB() IVariSeatFixDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IVariSeatFixDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IVariSeatFixDo
	Not(conds ...gen.Condition) IVariSeatFixDo
	Or(conds ...gen.Condition) IVariSeatFixDo
	Select(conds ...field.Expr) IVariSeatFixDo
	Where(conds ...gen.Condition) IVariSeatFixDo
	Order(conds ...field.Expr) IVariSeatFixDo
	Distinct(cols ...field.Expr) IVariSeatFixDo
	Omit(cols ...field.Expr) IVariSeatFixDo
	Join(table schema.Tabler, on ...field.Expr) IVariSeatFixDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IVariSeatFixDo
	RightJoin(table schema.Tabler, on ...field.Expr) IVariSeatFixDo
	Group(cols ...field.Expr) IVariSeatFixDo
	Having(conds ...gen.Condition) IVariSeatFixDo
	Limit(limit int) IVariSeatFixDo
	Offset(offset int) IVariSeatFixDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IVariSeatFixDo
	Unscoped() IVariSeatFixDo
	Create(values ...*model.VariSeatFix) error
	CreateInBatches(values []*model.VariSeatFix, batchSize int) error
	Save(values ...*model.VariSeatFix) error
	First() (*model.VariSeatFix, error)
	Take() (*model.VariSeatFix, error)
	Last() (*model.VariSeatFix, error)
	Find() ([]*model.VariSeatFix, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.VariSeatFix, err error)
	FindInBatches(result *[]*model.VariSeatFix, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.VariSeatFix) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IVariSeatFixDo
	Assign(attrs ...field.AssignExpr) IVariSeatFixDo
	Joins(fields ...field.RelationField) IVariSeatFixDo
	Preload(fields ...field.RelationField) IVariSeatFixDo
	FirstOrInit() (*model.VariSeatFix, error)
	FirstOrCreate() (*model.VariSeatFix, error)
	FindByPage(offset int, limit int) (result []*model.VariSeatFix, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IVariSeatFixDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (v variSeatFixDo) Debug() IVariSeatFixDo {
	return v.withDO(v.DO.Debug())
}

func (v variSeatFixDo) WithContext(ctx context.Context) IVariSeatFixDo {
	return v.withDO(v.DO.WithContext(ctx))
}

func (v variSeatFixDo) ReadDB() IVariSeatFixDo {
	return v.Clauses(dbresolver.Read)
}

func (v variSeatFixDo) WriteDB() IVariSeatFixDo {
	return v.Clauses(dbresolver.Write)
}

func (v variSeatFixDo) Session(config *gorm.Session) IVariSeatFixDo {
	return v.withDO(v.DO.Session(config))
}

func (v variSeatFixDo) Clauses(conds ...clause.Expression) IVariSeatFixDo {
	return v.withDO(v.DO.Clauses(conds...))
}

func (v variSeatFixDo) Returning(value interface{}, columns ...string) IVariSeatFixDo {
	return v.withDO(v.DO.Returning(value, columns...))
}

func (v variSeatFixDo) Not(conds ...gen.Condition) IVariSeatFixDo {
	return v.withDO(v.DO.Not(conds...))
}

func (v variSeatFixDo) Or(conds ...gen.Condition) IVariSeatFixDo {
	return v.withDO(v.DO.Or(conds...))
}

func (v variSeatFixDo) Select(conds ...field.Expr) IVariSeatFixDo {
	return v.withDO(v.DO.Select(conds...))
}

func (v variSeatFixDo) Where(conds ...gen.Condition) IVariSeatFixDo {
	return v.withDO(v.DO.Where(conds...))
}

func (v variSeatFixDo) Order(conds ...field.Expr) IVariSeatFixDo {
	return v.withDO(v.DO.Order(conds...))
}

func (v variSeatFixDo) Distinct(cols ...field.Expr) IVariSeatFixDo {
	return v.withDO(v.DO.Distinct(cols...))
}

func (v variSeatFixDo) Omit(cols ...field.Expr) IVariSeatFixDo {
	return v.withDO(v.DO.Omit(cols...))
}

func (v variSeatFixDo) Join(table schema.Tabler, on ...field.Expr) IVariSeatFixDo {
	return v.withDO(v.DO.Join(table, on...))
}

func (v variSeatFixDo) LeftJoin(table schema.Tabler, on ...field.Expr) IVariSeatFixDo {
	return v.withDO(v.DO.LeftJoin(table, on...))
}

func (v variSeatFixDo) RightJoin(table schema.Tabler, on ...field.Expr) IVariSeatFixDo {
	return v.withDO(v.DO.RightJoin(table, on...))
}

func (v variSeatFixDo) Group(cols ...field.Expr) IVariSeatFixDo {
	return v.withDO(v.DO.Group(cols...))
}

func (v variSeatFixDo) Having(conds ...gen.Condition) IVariSeatFixDo {
	return v.withDO(v.DO.Having(conds...))
}

func (v variSeatFixDo) Limit(limit int) IVariSeatFixDo {
	return v.withDO(v.DO.Limit(limit))
}

func (v variSeatFixDo) Offset(offset int) IVariSeatFixDo {
	return v.withDO(v.DO.Offset(offset))
}

func (v variSeatFixDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IVariSeatFixDo {
	return v.withDO(v.DO.Scopes(funcs...))
}

func (v variSeatFixDo) Unscoped() IVariSeatFixDo {
	return v.withDO(v.DO.Unscoped())
}

func (v variSeatFixDo) Create(values ...*model.VariSeatFix) error {
	if len(values) == 0 {
		return nil
	}
	return v.DO.Create(values)
}

func (v variSeatFixDo) CreateInBatches(values []*model.VariSeatFix, batchSize int) error {
	return v.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (v variSeatFixDo) Save(values ...*model.VariSeatFix) error {
	if len(values) == 0 {
		return nil
	}
	return v.DO.Save(values)
}

func (v variSeatFixDo) First() (*model.VariSeatFix, error) {
	if result, err := v.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.VariSeatFix), nil
	}
}

func (v variSeatFixDo) Take() (*model.VariSeatFix, error) {
	if result, err := v.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.VariSeatFix), nil
	}
}

func (v variSeatFixDo) Last() (*model.VariSeatFix, error) {
	if result, err := v.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.VariSeatFix), nil
	}
}

func (v variSeatFixDo) Find() ([]*model.VariSeatFix, error) {
	result, err := v.DO.Find()
	return result.([]*model.VariSeatFix), err
}

func (v variSeatFixDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.VariSeatFix, err error) {
	buf := make([]*model.VariSeatFix, 0, batchSize)
	err = v.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (v variSeatFixDo) FindInBatches(result *[]*model.VariSeatFix, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return v.DO.FindInBatches(result, batchSize, fc)
}

func (v variSeatFixDo) Attrs(attrs ...field.AssignExpr) IVariSeatFixDo {
	return v.withDO(v.DO.Attrs(attrs...))
}

func (v variSeatFixDo) Assign(attrs ...field.AssignExpr) IVariSeatFixDo {
	return v.withDO(v.DO.Assign(attrs...))
}

func (v variSeatFixDo) Joins(fields ...field.RelationField) IVariSeatFixDo {
	for _, _f := range fields {
		v = *v.withDO(v.DO.Joins(_f))
	}
	return &v
}

func (v variSeatFixDo) Preload(fields ...field.RelationField) IVariSeatFixDo {
	for _, _f := range fields {
		v = *v.withDO(v.DO.Preload(_f))
	}
	return &v
}

func (v variSeatFixDo) FirstOrInit() (*model.VariSeatFix, error) {
	if result, err := v.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.VariSeatFix), nil
	}
}

func (v variSeatFixDo) FirstOrCreate() (*model.VariSeatFix, error) {
	if result, err := v.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.VariSeatFix), nil
	}
}

func (v variSeatFixDo) FindByPage(offset int, limit int) (result []*model.VariSeatFix, count int64, err error) {
	result, err = v.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = v.Offset(-1).Limit(-1).Count()
	return
}

func (v variSeatFixDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = v.Count()
	if err != nil {
		return
	}

	err = v.Offset(offset).Limit(limit).Scan(result)
	return
}

func (v variSeatFixDo) Scan(result interface{}) (err error) {
	return v.DO.Scan(result)
}

func (v variSeatFixDo) Delete(models ...*model.VariSeatFix) (result gen.ResultInfo, err error) {
	return v.DO.Delete(models)
}

func (v *variSeatFixDo) withDO(do gen.Dao) *variSeatFixDo {
	v.DO = *do.(*gen.DO)
	return v
}
