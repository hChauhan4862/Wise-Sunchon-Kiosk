// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newGATEHISTORY(db *gorm.DB, opts ...gen.DOOption) gATEHISTORY {
	_gATEHISTORY := gATEHISTORY{}

	_gATEHISTORY.gATEHISTORYDo.UseDB(db, opts...)
	_gATEHISTORY.gATEHISTORYDo.UseModel(&model.GATEHISTORY{})

	tableName := _gATEHISTORY.gATEHISTORYDo.TableName()
	_gATEHISTORY.ALL = field.NewAsterisk(tableName)
	_gATEHISTORY.SEQNO = field.NewInt64(tableName, "SEQNO")
	_gATEHISTORY.SCHOOLNO = field.NewString(tableName, "SCHOOLNO")
	_gATEHISTORY.GATE = field.NewInt64(tableName, "GATE")
	_gATEHISTORY.GATENO = field.NewString(tableName, "GATENO")
	_gATEHISTORY.GUBUN = field.NewString(tableName, "GUBUN")
	_gATEHISTORY.LOGTIME = field.NewTime(tableName, "LOGTIME")
	_gATEHISTORY.NAME = field.NewString(tableName, "NAME")
	_gATEHISTORY.SEX = field.NewString(tableName, "SEX")
	_gATEHISTORY.SOSOKCD1 = field.NewString(tableName, "SOSOK_CD1")
	_gATEHISTORY.SOSOKCD2 = field.NewString(tableName, "SOSOK_CD2")
	_gATEHISTORY.SINBUN = field.NewString(tableName, "SINBUN")
	_gATEHISTORY.STATUSCD = field.NewString(tableName, "STATUS_CD")

	_gATEHISTORY.fillFieldMap()

	return _gATEHISTORY
}

type gATEHISTORY struct {
	gATEHISTORYDo

	ALL      field.Asterisk
	SEQNO    field.Int64
	SCHOOLNO field.String
	GATE     field.Int64
	GATENO   field.String
	GUBUN    field.String
	LOGTIME  field.Time
	NAME     field.String
	SEX      field.String
	SOSOKCD1 field.String
	SOSOKCD2 field.String
	SINBUN   field.String
	STATUSCD field.String

	fieldMap map[string]field.Expr
}

func (g gATEHISTORY) Table(newTableName string) *gATEHISTORY {
	g.gATEHISTORYDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g gATEHISTORY) As(alias string) *gATEHISTORY {
	g.gATEHISTORYDo.DO = *(g.gATEHISTORYDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *gATEHISTORY) updateTableName(table string) *gATEHISTORY {
	g.ALL = field.NewAsterisk(table)
	g.SEQNO = field.NewInt64(table, "SEQNO")
	g.SCHOOLNO = field.NewString(table, "SCHOOLNO")
	g.GATE = field.NewInt64(table, "GATE")
	g.GATENO = field.NewString(table, "GATENO")
	g.GUBUN = field.NewString(table, "GUBUN")
	g.LOGTIME = field.NewTime(table, "LOGTIME")
	g.NAME = field.NewString(table, "NAME")
	g.SEX = field.NewString(table, "SEX")
	g.SOSOKCD1 = field.NewString(table, "SOSOK_CD1")
	g.SOSOKCD2 = field.NewString(table, "SOSOK_CD2")
	g.SINBUN = field.NewString(table, "SINBUN")
	g.STATUSCD = field.NewString(table, "STATUS_CD")

	g.fillFieldMap()

	return g
}

func (g *gATEHISTORY) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *gATEHISTORY) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 12)
	g.fieldMap["SEQNO"] = g.SEQNO
	g.fieldMap["SCHOOLNO"] = g.SCHOOLNO
	g.fieldMap["GATE"] = g.GATE
	g.fieldMap["GATENO"] = g.GATENO
	g.fieldMap["GUBUN"] = g.GUBUN
	g.fieldMap["LOGTIME"] = g.LOGTIME
	g.fieldMap["NAME"] = g.NAME
	g.fieldMap["SEX"] = g.SEX
	g.fieldMap["SOSOK_CD1"] = g.SOSOKCD1
	g.fieldMap["SOSOK_CD2"] = g.SOSOKCD2
	g.fieldMap["SINBUN"] = g.SINBUN
	g.fieldMap["STATUS_CD"] = g.STATUSCD
}

func (g gATEHISTORY) clone(db *gorm.DB) gATEHISTORY {
	g.gATEHISTORYDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g gATEHISTORY) replaceDB(db *gorm.DB) gATEHISTORY {
	g.gATEHISTORYDo.ReplaceDB(db)
	return g
}

type gATEHISTORYDo struct{ gen.DO }

type IGATEHISTORYDo interface {
	gen.SubQuery
	Debug() IGATEHISTORYDo
	WithContext(ctx context.Context) IGATEHISTORYDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGATEHISTORYDo
	WriteDB() IGATEHISTORYDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGATEHISTORYDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGATEHISTORYDo
	Not(conds ...gen.Condition) IGATEHISTORYDo
	Or(conds ...gen.Condition) IGATEHISTORYDo
	Select(conds ...field.Expr) IGATEHISTORYDo
	Where(conds ...gen.Condition) IGATEHISTORYDo
	Order(conds ...field.Expr) IGATEHISTORYDo
	Distinct(cols ...field.Expr) IGATEHISTORYDo
	Omit(cols ...field.Expr) IGATEHISTORYDo
	Join(table schema.Tabler, on ...field.Expr) IGATEHISTORYDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGATEHISTORYDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGATEHISTORYDo
	Group(cols ...field.Expr) IGATEHISTORYDo
	Having(conds ...gen.Condition) IGATEHISTORYDo
	Limit(limit int) IGATEHISTORYDo
	Offset(offset int) IGATEHISTORYDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGATEHISTORYDo
	Unscoped() IGATEHISTORYDo
	Create(values ...*model.GATEHISTORY) error
	CreateInBatches(values []*model.GATEHISTORY, batchSize int) error
	Save(values ...*model.GATEHISTORY) error
	First() (*model.GATEHISTORY, error)
	Take() (*model.GATEHISTORY, error)
	Last() (*model.GATEHISTORY, error)
	Find() ([]*model.GATEHISTORY, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GATEHISTORY, err error)
	FindInBatches(result *[]*model.GATEHISTORY, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GATEHISTORY) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGATEHISTORYDo
	Assign(attrs ...field.AssignExpr) IGATEHISTORYDo
	Joins(fields ...field.RelationField) IGATEHISTORYDo
	Preload(fields ...field.RelationField) IGATEHISTORYDo
	FirstOrInit() (*model.GATEHISTORY, error)
	FirstOrCreate() (*model.GATEHISTORY, error)
	FindByPage(offset int, limit int) (result []*model.GATEHISTORY, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGATEHISTORYDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g gATEHISTORYDo) Debug() IGATEHISTORYDo {
	return g.withDO(g.DO.Debug())
}

func (g gATEHISTORYDo) WithContext(ctx context.Context) IGATEHISTORYDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g gATEHISTORYDo) ReadDB() IGATEHISTORYDo {
	return g.Clauses(dbresolver.Read)
}

func (g gATEHISTORYDo) WriteDB() IGATEHISTORYDo {
	return g.Clauses(dbresolver.Write)
}

func (g gATEHISTORYDo) Session(config *gorm.Session) IGATEHISTORYDo {
	return g.withDO(g.DO.Session(config))
}

func (g gATEHISTORYDo) Clauses(conds ...clause.Expression) IGATEHISTORYDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g gATEHISTORYDo) Returning(value interface{}, columns ...string) IGATEHISTORYDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g gATEHISTORYDo) Not(conds ...gen.Condition) IGATEHISTORYDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g gATEHISTORYDo) Or(conds ...gen.Condition) IGATEHISTORYDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g gATEHISTORYDo) Select(conds ...field.Expr) IGATEHISTORYDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g gATEHISTORYDo) Where(conds ...gen.Condition) IGATEHISTORYDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g gATEHISTORYDo) Order(conds ...field.Expr) IGATEHISTORYDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g gATEHISTORYDo) Distinct(cols ...field.Expr) IGATEHISTORYDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g gATEHISTORYDo) Omit(cols ...field.Expr) IGATEHISTORYDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g gATEHISTORYDo) Join(table schema.Tabler, on ...field.Expr) IGATEHISTORYDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g gATEHISTORYDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGATEHISTORYDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g gATEHISTORYDo) RightJoin(table schema.Tabler, on ...field.Expr) IGATEHISTORYDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g gATEHISTORYDo) Group(cols ...field.Expr) IGATEHISTORYDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g gATEHISTORYDo) Having(conds ...gen.Condition) IGATEHISTORYDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g gATEHISTORYDo) Limit(limit int) IGATEHISTORYDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g gATEHISTORYDo) Offset(offset int) IGATEHISTORYDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g gATEHISTORYDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGATEHISTORYDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g gATEHISTORYDo) Unscoped() IGATEHISTORYDo {
	return g.withDO(g.DO.Unscoped())
}

func (g gATEHISTORYDo) Create(values ...*model.GATEHISTORY) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g gATEHISTORYDo) CreateInBatches(values []*model.GATEHISTORY, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g gATEHISTORYDo) Save(values ...*model.GATEHISTORY) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g gATEHISTORYDo) First() (*model.GATEHISTORY, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GATEHISTORY), nil
	}
}

func (g gATEHISTORYDo) Take() (*model.GATEHISTORY, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GATEHISTORY), nil
	}
}

func (g gATEHISTORYDo) Last() (*model.GATEHISTORY, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GATEHISTORY), nil
	}
}

func (g gATEHISTORYDo) Find() ([]*model.GATEHISTORY, error) {
	result, err := g.DO.Find()
	return result.([]*model.GATEHISTORY), err
}

func (g gATEHISTORYDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GATEHISTORY, err error) {
	buf := make([]*model.GATEHISTORY, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g gATEHISTORYDo) FindInBatches(result *[]*model.GATEHISTORY, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g gATEHISTORYDo) Attrs(attrs ...field.AssignExpr) IGATEHISTORYDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g gATEHISTORYDo) Assign(attrs ...field.AssignExpr) IGATEHISTORYDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g gATEHISTORYDo) Joins(fields ...field.RelationField) IGATEHISTORYDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g gATEHISTORYDo) Preload(fields ...field.RelationField) IGATEHISTORYDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g gATEHISTORYDo) FirstOrInit() (*model.GATEHISTORY, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GATEHISTORY), nil
	}
}

func (g gATEHISTORYDo) FirstOrCreate() (*model.GATEHISTORY, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GATEHISTORY), nil
	}
}

func (g gATEHISTORYDo) FindByPage(offset int, limit int) (result []*model.GATEHISTORY, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g gATEHISTORYDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g gATEHISTORYDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g gATEHISTORYDo) Delete(models ...*model.GATEHISTORY) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *gATEHISTORYDo) withDO(do gen.Dao) *gATEHISTORYDo {
	g.DO = *do.(*gen.DO)
	return g
}
