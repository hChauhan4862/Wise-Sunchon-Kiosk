// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newKioskNotice(db *gorm.DB, opts ...gen.DOOption) kioskNotice {
	_kioskNotice := kioskNotice{}

	_kioskNotice.kioskNoticeDo.UseDB(db, opts...)
	_kioskNotice.kioskNoticeDo.UseModel(&model.KioskNotice{})

	tableName := _kioskNotice.kioskNoticeDo.TableName()
	_kioskNotice.ALL = field.NewAsterisk(tableName)
	_kioskNotice.NoticeNo = field.NewInt64(tableName, "NoticeNo")
	_kioskNotice.NoticeType = field.NewInt64(tableName, "NoticeType")
	_kioskNotice.Title = field.NewString(tableName, "Title")
	_kioskNotice.ItemNo = field.NewInt64(tableName, "ItemNo")
	_kioskNotice.Contents = field.NewString(tableName, "Contents")
	_kioskNotice.UseStart = field.NewTime(tableName, "UseStart")
	_kioskNotice.UseExpire = field.NewTime(tableName, "UseExpire")
	_kioskNotice.InsertTime = field.NewTime(tableName, "InsertTime")
	_kioskNotice.AdminID = field.NewString(tableName, "AdminID")
	_kioskNotice.IsDelete = field.NewInt64(tableName, "IsDelete")
	_kioskNotice.ENTITLE = field.NewString(tableName, "EN_TITLE")
	_kioskNotice.ENCONTENTS = field.NewString(tableName, "EN_CONTENTS")
	_kioskNotice.NoticeColor = field.NewString(tableName, "NoticeColor")
	_kioskNotice.LibNo = field.NewInt64(tableName, "LibNo")
	_kioskNotice.DeviceType = field.NewInt64(tableName, "Device_Type")

	_kioskNotice.fillFieldMap()

	return _kioskNotice
}

type kioskNotice struct {
	kioskNoticeDo

	ALL         field.Asterisk
	NoticeNo    field.Int64
	NoticeType  field.Int64
	Title       field.String
	ItemNo      field.Int64
	Contents    field.String
	UseStart    field.Time
	UseExpire   field.Time
	InsertTime  field.Time
	AdminID     field.String
	IsDelete    field.Int64
	ENTITLE     field.String
	ENCONTENTS  field.String
	NoticeColor field.String
	LibNo       field.Int64
	DeviceType  field.Int64

	fieldMap map[string]field.Expr
}

func (k kioskNotice) Table(newTableName string) *kioskNotice {
	k.kioskNoticeDo.UseTable(newTableName)
	return k.updateTableName(newTableName)
}

func (k kioskNotice) As(alias string) *kioskNotice {
	k.kioskNoticeDo.DO = *(k.kioskNoticeDo.As(alias).(*gen.DO))
	return k.updateTableName(alias)
}

func (k *kioskNotice) updateTableName(table string) *kioskNotice {
	k.ALL = field.NewAsterisk(table)
	k.NoticeNo = field.NewInt64(table, "NoticeNo")
	k.NoticeType = field.NewInt64(table, "NoticeType")
	k.Title = field.NewString(table, "Title")
	k.ItemNo = field.NewInt64(table, "ItemNo")
	k.Contents = field.NewString(table, "Contents")
	k.UseStart = field.NewTime(table, "UseStart")
	k.UseExpire = field.NewTime(table, "UseExpire")
	k.InsertTime = field.NewTime(table, "InsertTime")
	k.AdminID = field.NewString(table, "AdminID")
	k.IsDelete = field.NewInt64(table, "IsDelete")
	k.ENTITLE = field.NewString(table, "EN_TITLE")
	k.ENCONTENTS = field.NewString(table, "EN_CONTENTS")
	k.NoticeColor = field.NewString(table, "NoticeColor")
	k.LibNo = field.NewInt64(table, "LibNo")
	k.DeviceType = field.NewInt64(table, "Device_Type")

	k.fillFieldMap()

	return k
}

func (k *kioskNotice) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := k.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (k *kioskNotice) fillFieldMap() {
	k.fieldMap = make(map[string]field.Expr, 15)
	k.fieldMap["NoticeNo"] = k.NoticeNo
	k.fieldMap["NoticeType"] = k.NoticeType
	k.fieldMap["Title"] = k.Title
	k.fieldMap["ItemNo"] = k.ItemNo
	k.fieldMap["Contents"] = k.Contents
	k.fieldMap["UseStart"] = k.UseStart
	k.fieldMap["UseExpire"] = k.UseExpire
	k.fieldMap["InsertTime"] = k.InsertTime
	k.fieldMap["AdminID"] = k.AdminID
	k.fieldMap["IsDelete"] = k.IsDelete
	k.fieldMap["EN_TITLE"] = k.ENTITLE
	k.fieldMap["EN_CONTENTS"] = k.ENCONTENTS
	k.fieldMap["NoticeColor"] = k.NoticeColor
	k.fieldMap["LibNo"] = k.LibNo
	k.fieldMap["Device_Type"] = k.DeviceType
}

func (k kioskNotice) clone(db *gorm.DB) kioskNotice {
	k.kioskNoticeDo.ReplaceConnPool(db.Statement.ConnPool)
	return k
}

func (k kioskNotice) replaceDB(db *gorm.DB) kioskNotice {
	k.kioskNoticeDo.ReplaceDB(db)
	return k
}

type kioskNoticeDo struct{ gen.DO }

type IKioskNoticeDo interface {
	gen.SubQuery
	Debug() IKioskNoticeDo
	WithContext(ctx context.Context) IKioskNoticeDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IKioskNoticeDo
	WriteDB() IKioskNoticeDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IKioskNoticeDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IKioskNoticeDo
	Not(conds ...gen.Condition) IKioskNoticeDo
	Or(conds ...gen.Condition) IKioskNoticeDo
	Select(conds ...field.Expr) IKioskNoticeDo
	Where(conds ...gen.Condition) IKioskNoticeDo
	Order(conds ...field.Expr) IKioskNoticeDo
	Distinct(cols ...field.Expr) IKioskNoticeDo
	Omit(cols ...field.Expr) IKioskNoticeDo
	Join(table schema.Tabler, on ...field.Expr) IKioskNoticeDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IKioskNoticeDo
	RightJoin(table schema.Tabler, on ...field.Expr) IKioskNoticeDo
	Group(cols ...field.Expr) IKioskNoticeDo
	Having(conds ...gen.Condition) IKioskNoticeDo
	Limit(limit int) IKioskNoticeDo
	Offset(offset int) IKioskNoticeDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IKioskNoticeDo
	Unscoped() IKioskNoticeDo
	Create(values ...*model.KioskNotice) error
	CreateInBatches(values []*model.KioskNotice, batchSize int) error
	Save(values ...*model.KioskNotice) error
	First() (*model.KioskNotice, error)
	Take() (*model.KioskNotice, error)
	Last() (*model.KioskNotice, error)
	Find() ([]*model.KioskNotice, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.KioskNotice, err error)
	FindInBatches(result *[]*model.KioskNotice, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.KioskNotice) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IKioskNoticeDo
	Assign(attrs ...field.AssignExpr) IKioskNoticeDo
	Joins(fields ...field.RelationField) IKioskNoticeDo
	Preload(fields ...field.RelationField) IKioskNoticeDo
	FirstOrInit() (*model.KioskNotice, error)
	FirstOrCreate() (*model.KioskNotice, error)
	FindByPage(offset int, limit int) (result []*model.KioskNotice, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IKioskNoticeDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (k kioskNoticeDo) Debug() IKioskNoticeDo {
	return k.withDO(k.DO.Debug())
}

func (k kioskNoticeDo) WithContext(ctx context.Context) IKioskNoticeDo {
	return k.withDO(k.DO.WithContext(ctx))
}

func (k kioskNoticeDo) ReadDB() IKioskNoticeDo {
	return k.Clauses(dbresolver.Read)
}

func (k kioskNoticeDo) WriteDB() IKioskNoticeDo {
	return k.Clauses(dbresolver.Write)
}

func (k kioskNoticeDo) Session(config *gorm.Session) IKioskNoticeDo {
	return k.withDO(k.DO.Session(config))
}

func (k kioskNoticeDo) Clauses(conds ...clause.Expression) IKioskNoticeDo {
	return k.withDO(k.DO.Clauses(conds...))
}

func (k kioskNoticeDo) Returning(value interface{}, columns ...string) IKioskNoticeDo {
	return k.withDO(k.DO.Returning(value, columns...))
}

func (k kioskNoticeDo) Not(conds ...gen.Condition) IKioskNoticeDo {
	return k.withDO(k.DO.Not(conds...))
}

func (k kioskNoticeDo) Or(conds ...gen.Condition) IKioskNoticeDo {
	return k.withDO(k.DO.Or(conds...))
}

func (k kioskNoticeDo) Select(conds ...field.Expr) IKioskNoticeDo {
	return k.withDO(k.DO.Select(conds...))
}

func (k kioskNoticeDo) Where(conds ...gen.Condition) IKioskNoticeDo {
	return k.withDO(k.DO.Where(conds...))
}

func (k kioskNoticeDo) Order(conds ...field.Expr) IKioskNoticeDo {
	return k.withDO(k.DO.Order(conds...))
}

func (k kioskNoticeDo) Distinct(cols ...field.Expr) IKioskNoticeDo {
	return k.withDO(k.DO.Distinct(cols...))
}

func (k kioskNoticeDo) Omit(cols ...field.Expr) IKioskNoticeDo {
	return k.withDO(k.DO.Omit(cols...))
}

func (k kioskNoticeDo) Join(table schema.Tabler, on ...field.Expr) IKioskNoticeDo {
	return k.withDO(k.DO.Join(table, on...))
}

func (k kioskNoticeDo) LeftJoin(table schema.Tabler, on ...field.Expr) IKioskNoticeDo {
	return k.withDO(k.DO.LeftJoin(table, on...))
}

func (k kioskNoticeDo) RightJoin(table schema.Tabler, on ...field.Expr) IKioskNoticeDo {
	return k.withDO(k.DO.RightJoin(table, on...))
}

func (k kioskNoticeDo) Group(cols ...field.Expr) IKioskNoticeDo {
	return k.withDO(k.DO.Group(cols...))
}

func (k kioskNoticeDo) Having(conds ...gen.Condition) IKioskNoticeDo {
	return k.withDO(k.DO.Having(conds...))
}

func (k kioskNoticeDo) Limit(limit int) IKioskNoticeDo {
	return k.withDO(k.DO.Limit(limit))
}

func (k kioskNoticeDo) Offset(offset int) IKioskNoticeDo {
	return k.withDO(k.DO.Offset(offset))
}

func (k kioskNoticeDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IKioskNoticeDo {
	return k.withDO(k.DO.Scopes(funcs...))
}

func (k kioskNoticeDo) Unscoped() IKioskNoticeDo {
	return k.withDO(k.DO.Unscoped())
}

func (k kioskNoticeDo) Create(values ...*model.KioskNotice) error {
	if len(values) == 0 {
		return nil
	}
	return k.DO.Create(values)
}

func (k kioskNoticeDo) CreateInBatches(values []*model.KioskNotice, batchSize int) error {
	return k.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (k kioskNoticeDo) Save(values ...*model.KioskNotice) error {
	if len(values) == 0 {
		return nil
	}
	return k.DO.Save(values)
}

func (k kioskNoticeDo) First() (*model.KioskNotice, error) {
	if result, err := k.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.KioskNotice), nil
	}
}

func (k kioskNoticeDo) Take() (*model.KioskNotice, error) {
	if result, err := k.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.KioskNotice), nil
	}
}

func (k kioskNoticeDo) Last() (*model.KioskNotice, error) {
	if result, err := k.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.KioskNotice), nil
	}
}

func (k kioskNoticeDo) Find() ([]*model.KioskNotice, error) {
	result, err := k.DO.Find()
	return result.([]*model.KioskNotice), err
}

func (k kioskNoticeDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.KioskNotice, err error) {
	buf := make([]*model.KioskNotice, 0, batchSize)
	err = k.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (k kioskNoticeDo) FindInBatches(result *[]*model.KioskNotice, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return k.DO.FindInBatches(result, batchSize, fc)
}

func (k kioskNoticeDo) Attrs(attrs ...field.AssignExpr) IKioskNoticeDo {
	return k.withDO(k.DO.Attrs(attrs...))
}

func (k kioskNoticeDo) Assign(attrs ...field.AssignExpr) IKioskNoticeDo {
	return k.withDO(k.DO.Assign(attrs...))
}

func (k kioskNoticeDo) Joins(fields ...field.RelationField) IKioskNoticeDo {
	for _, _f := range fields {
		k = *k.withDO(k.DO.Joins(_f))
	}
	return &k
}

func (k kioskNoticeDo) Preload(fields ...field.RelationField) IKioskNoticeDo {
	for _, _f := range fields {
		k = *k.withDO(k.DO.Preload(_f))
	}
	return &k
}

func (k kioskNoticeDo) FirstOrInit() (*model.KioskNotice, error) {
	if result, err := k.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.KioskNotice), nil
	}
}

func (k kioskNoticeDo) FirstOrCreate() (*model.KioskNotice, error) {
	if result, err := k.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.KioskNotice), nil
	}
}

func (k kioskNoticeDo) FindByPage(offset int, limit int) (result []*model.KioskNotice, count int64, err error) {
	result, err = k.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = k.Offset(-1).Limit(-1).Count()
	return
}

func (k kioskNoticeDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = k.Count()
	if err != nil {
		return
	}

	err = k.Offset(offset).Limit(limit).Scan(result)
	return
}

func (k kioskNoticeDo) Scan(result interface{}) (err error) {
	return k.DO.Scan(result)
}

func (k kioskNoticeDo) Delete(models ...*model.KioskNotice) (result gen.ResultInfo, err error) {
	return k.DO.Delete(models)
}

func (k *kioskNoticeDo) withDO(do gen.Dao) *kioskNoticeDo {
	k.DO = *do.(*gen.DO)
	return k
}
