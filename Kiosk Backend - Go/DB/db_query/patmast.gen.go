// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newPATMAST(db *gorm.DB, opts ...gen.DOOption) pATMAST {
	_pATMAST := pATMAST{}

	_pATMAST.pATMASTDo.UseDB(db, opts...)
	_pATMAST.pATMASTDo.UseModel(&model.PATMAST{})

	tableName := _pATMAST.pATMASTDo.TableName()
	_pATMAST.ALL = field.NewAsterisk(tableName)
	_pATMAST.AltPid = field.NewString(tableName, "alt_pid")
	_pATMAST.RpstPersNo = field.NewString(tableName, "rpst_pers_no")
	_pATMAST.Username = field.NewString(tableName, "username")
	_pATMAST.PatType = field.NewString(tableName, "pat_type")
	_pATMAST.PatName = field.NewString(tableName, "pat_name")
	_pATMAST.DeptCode = field.NewString(tableName, "dept_code")
	_pATMAST.DeptName = field.NewString(tableName, "dept_name")
	_pATMAST.CollegeCode = field.NewString(tableName, "college_code")
	_pATMAST.CollegeName = field.NewString(tableName, "college_name")
	_pATMAST.Phone3 = field.NewString(tableName, "phone3")
	_pATMAST.Email = field.NewString(tableName, "email")
	_pATMAST.DateExprd = field.NewString(tableName, "date_exprd")
	_pATMAST.PatStat = field.NewString(tableName, "pat_stat")
	_pATMAST.Ipid = field.NewInt64(tableName, "ipid")
	_pATMAST.Userpwd = field.NewString(tableName, "userpwd")

	_pATMAST.fillFieldMap()

	return _pATMAST
}

type pATMAST struct {
	pATMASTDo

	ALL         field.Asterisk
	AltPid      field.String
	RpstPersNo  field.String
	Username    field.String
	PatType     field.String
	PatName     field.String
	DeptCode    field.String
	DeptName    field.String
	CollegeCode field.String
	CollegeName field.String
	Phone3      field.String
	Email       field.String
	DateExprd   field.String
	PatStat     field.String
	Ipid        field.Int64
	Userpwd     field.String

	fieldMap map[string]field.Expr
}

func (p pATMAST) Table(newTableName string) *pATMAST {
	p.pATMASTDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p pATMAST) As(alias string) *pATMAST {
	p.pATMASTDo.DO = *(p.pATMASTDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *pATMAST) updateTableName(table string) *pATMAST {
	p.ALL = field.NewAsterisk(table)
	p.AltPid = field.NewString(table, "alt_pid")
	p.RpstPersNo = field.NewString(table, "rpst_pers_no")
	p.Username = field.NewString(table, "username")
	p.PatType = field.NewString(table, "pat_type")
	p.PatName = field.NewString(table, "pat_name")
	p.DeptCode = field.NewString(table, "dept_code")
	p.DeptName = field.NewString(table, "dept_name")
	p.CollegeCode = field.NewString(table, "college_code")
	p.CollegeName = field.NewString(table, "college_name")
	p.Phone3 = field.NewString(table, "phone3")
	p.Email = field.NewString(table, "email")
	p.DateExprd = field.NewString(table, "date_exprd")
	p.PatStat = field.NewString(table, "pat_stat")
	p.Ipid = field.NewInt64(table, "ipid")
	p.Userpwd = field.NewString(table, "userpwd")

	p.fillFieldMap()

	return p
}

func (p *pATMAST) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *pATMAST) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 15)
	p.fieldMap["alt_pid"] = p.AltPid
	p.fieldMap["rpst_pers_no"] = p.RpstPersNo
	p.fieldMap["username"] = p.Username
	p.fieldMap["pat_type"] = p.PatType
	p.fieldMap["pat_name"] = p.PatName
	p.fieldMap["dept_code"] = p.DeptCode
	p.fieldMap["dept_name"] = p.DeptName
	p.fieldMap["college_code"] = p.CollegeCode
	p.fieldMap["college_name"] = p.CollegeName
	p.fieldMap["phone3"] = p.Phone3
	p.fieldMap["email"] = p.Email
	p.fieldMap["date_exprd"] = p.DateExprd
	p.fieldMap["pat_stat"] = p.PatStat
	p.fieldMap["ipid"] = p.Ipid
	p.fieldMap["userpwd"] = p.Userpwd
}

func (p pATMAST) clone(db *gorm.DB) pATMAST {
	p.pATMASTDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p pATMAST) replaceDB(db *gorm.DB) pATMAST {
	p.pATMASTDo.ReplaceDB(db)
	return p
}

type pATMASTDo struct{ gen.DO }

type IPATMASTDo interface {
	gen.SubQuery
	Debug() IPATMASTDo
	WithContext(ctx context.Context) IPATMASTDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPATMASTDo
	WriteDB() IPATMASTDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPATMASTDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPATMASTDo
	Not(conds ...gen.Condition) IPATMASTDo
	Or(conds ...gen.Condition) IPATMASTDo
	Select(conds ...field.Expr) IPATMASTDo
	Where(conds ...gen.Condition) IPATMASTDo
	Order(conds ...field.Expr) IPATMASTDo
	Distinct(cols ...field.Expr) IPATMASTDo
	Omit(cols ...field.Expr) IPATMASTDo
	Join(table schema.Tabler, on ...field.Expr) IPATMASTDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPATMASTDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPATMASTDo
	Group(cols ...field.Expr) IPATMASTDo
	Having(conds ...gen.Condition) IPATMASTDo
	Limit(limit int) IPATMASTDo
	Offset(offset int) IPATMASTDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPATMASTDo
	Unscoped() IPATMASTDo
	Create(values ...*model.PATMAST) error
	CreateInBatches(values []*model.PATMAST, batchSize int) error
	Save(values ...*model.PATMAST) error
	First() (*model.PATMAST, error)
	Take() (*model.PATMAST, error)
	Last() (*model.PATMAST, error)
	Find() ([]*model.PATMAST, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PATMAST, err error)
	FindInBatches(result *[]*model.PATMAST, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PATMAST) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPATMASTDo
	Assign(attrs ...field.AssignExpr) IPATMASTDo
	Joins(fields ...field.RelationField) IPATMASTDo
	Preload(fields ...field.RelationField) IPATMASTDo
	FirstOrInit() (*model.PATMAST, error)
	FirstOrCreate() (*model.PATMAST, error)
	FindByPage(offset int, limit int) (result []*model.PATMAST, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPATMASTDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p pATMASTDo) Debug() IPATMASTDo {
	return p.withDO(p.DO.Debug())
}

func (p pATMASTDo) WithContext(ctx context.Context) IPATMASTDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p pATMASTDo) ReadDB() IPATMASTDo {
	return p.Clauses(dbresolver.Read)
}

func (p pATMASTDo) WriteDB() IPATMASTDo {
	return p.Clauses(dbresolver.Write)
}

func (p pATMASTDo) Session(config *gorm.Session) IPATMASTDo {
	return p.withDO(p.DO.Session(config))
}

func (p pATMASTDo) Clauses(conds ...clause.Expression) IPATMASTDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p pATMASTDo) Returning(value interface{}, columns ...string) IPATMASTDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p pATMASTDo) Not(conds ...gen.Condition) IPATMASTDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p pATMASTDo) Or(conds ...gen.Condition) IPATMASTDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p pATMASTDo) Select(conds ...field.Expr) IPATMASTDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p pATMASTDo) Where(conds ...gen.Condition) IPATMASTDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p pATMASTDo) Order(conds ...field.Expr) IPATMASTDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p pATMASTDo) Distinct(cols ...field.Expr) IPATMASTDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p pATMASTDo) Omit(cols ...field.Expr) IPATMASTDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p pATMASTDo) Join(table schema.Tabler, on ...field.Expr) IPATMASTDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p pATMASTDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPATMASTDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p pATMASTDo) RightJoin(table schema.Tabler, on ...field.Expr) IPATMASTDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p pATMASTDo) Group(cols ...field.Expr) IPATMASTDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p pATMASTDo) Having(conds ...gen.Condition) IPATMASTDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p pATMASTDo) Limit(limit int) IPATMASTDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p pATMASTDo) Offset(offset int) IPATMASTDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p pATMASTDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPATMASTDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p pATMASTDo) Unscoped() IPATMASTDo {
	return p.withDO(p.DO.Unscoped())
}

func (p pATMASTDo) Create(values ...*model.PATMAST) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p pATMASTDo) CreateInBatches(values []*model.PATMAST, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p pATMASTDo) Save(values ...*model.PATMAST) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p pATMASTDo) First() (*model.PATMAST, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMAST), nil
	}
}

func (p pATMASTDo) Take() (*model.PATMAST, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMAST), nil
	}
}

func (p pATMASTDo) Last() (*model.PATMAST, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMAST), nil
	}
}

func (p pATMASTDo) Find() ([]*model.PATMAST, error) {
	result, err := p.DO.Find()
	return result.([]*model.PATMAST), err
}

func (p pATMASTDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PATMAST, err error) {
	buf := make([]*model.PATMAST, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p pATMASTDo) FindInBatches(result *[]*model.PATMAST, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p pATMASTDo) Attrs(attrs ...field.AssignExpr) IPATMASTDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p pATMASTDo) Assign(attrs ...field.AssignExpr) IPATMASTDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p pATMASTDo) Joins(fields ...field.RelationField) IPATMASTDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p pATMASTDo) Preload(fields ...field.RelationField) IPATMASTDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p pATMASTDo) FirstOrInit() (*model.PATMAST, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMAST), nil
	}
}

func (p pATMASTDo) FirstOrCreate() (*model.PATMAST, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMAST), nil
	}
}

func (p pATMASTDo) FindByPage(offset int, limit int) (result []*model.PATMAST, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p pATMASTDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p pATMASTDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p pATMASTDo) Delete(models ...*model.PATMAST) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *pATMASTDo) withDO(do gen.Dao) *pATMASTDo {
	p.DO = *do.(*gen.DO)
	return p
}
