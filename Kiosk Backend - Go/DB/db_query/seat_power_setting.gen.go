// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newSeatPowerSetting(db *gorm.DB, opts ...gen.DOOption) seatPowerSetting {
	_seatPowerSetting := seatPowerSetting{}

	_seatPowerSetting.seatPowerSettingDo.UseDB(db, opts...)
	_seatPowerSetting.seatPowerSettingDo.UseModel(&model.SeatPowerSetting{})

	tableName := _seatPowerSetting.seatPowerSettingDo.TableName()
	_seatPowerSetting.ALL = field.NewAsterisk(tableName)
	_seatPowerSetting.RoomNo = field.NewInt64(tableName, "room_no")
	_seatPowerSetting.SeatNo = field.NewInt64(tableName, "seat_no")
	_seatPowerSetting.ComPort = field.NewInt64(tableName, "com_port")
	_seatPowerSetting.ControlNo = field.NewInt64(tableName, "control_no")
	_seatPowerSetting.RelayNo = field.NewInt64(tableName, "relay_no")
	_seatPowerSetting.State1 = field.NewString(tableName, "state1")
	_seatPowerSetting.Group1 = field.NewString(tableName, "group1")
	_seatPowerSetting.Group2 = field.NewString(tableName, "group2")
	_seatPowerSetting.Group3 = field.NewString(tableName, "group3")
	_seatPowerSetting.Group4 = field.NewString(tableName, "group4")
	_seatPowerSetting.Group5 = field.NewString(tableName, "group5")
	_seatPowerSetting.LastUdate = field.NewString(tableName, "last_udate")

	_seatPowerSetting.fillFieldMap()

	return _seatPowerSetting
}

type seatPowerSetting struct {
	seatPowerSettingDo

	ALL       field.Asterisk
	RoomNo    field.Int64
	SeatNo    field.Int64
	ComPort   field.Int64
	ControlNo field.Int64
	RelayNo   field.Int64
	State1    field.String
	Group1    field.String
	Group2    field.String
	Group3    field.String
	Group4    field.String
	Group5    field.String
	LastUdate field.String

	fieldMap map[string]field.Expr
}

func (s seatPowerSetting) Table(newTableName string) *seatPowerSetting {
	s.seatPowerSettingDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s seatPowerSetting) As(alias string) *seatPowerSetting {
	s.seatPowerSettingDo.DO = *(s.seatPowerSettingDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *seatPowerSetting) updateTableName(table string) *seatPowerSetting {
	s.ALL = field.NewAsterisk(table)
	s.RoomNo = field.NewInt64(table, "room_no")
	s.SeatNo = field.NewInt64(table, "seat_no")
	s.ComPort = field.NewInt64(table, "com_port")
	s.ControlNo = field.NewInt64(table, "control_no")
	s.RelayNo = field.NewInt64(table, "relay_no")
	s.State1 = field.NewString(table, "state1")
	s.Group1 = field.NewString(table, "group1")
	s.Group2 = field.NewString(table, "group2")
	s.Group3 = field.NewString(table, "group3")
	s.Group4 = field.NewString(table, "group4")
	s.Group5 = field.NewString(table, "group5")
	s.LastUdate = field.NewString(table, "last_udate")

	s.fillFieldMap()

	return s
}

func (s *seatPowerSetting) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *seatPowerSetting) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 12)
	s.fieldMap["room_no"] = s.RoomNo
	s.fieldMap["seat_no"] = s.SeatNo
	s.fieldMap["com_port"] = s.ComPort
	s.fieldMap["control_no"] = s.ControlNo
	s.fieldMap["relay_no"] = s.RelayNo
	s.fieldMap["state1"] = s.State1
	s.fieldMap["group1"] = s.Group1
	s.fieldMap["group2"] = s.Group2
	s.fieldMap["group3"] = s.Group3
	s.fieldMap["group4"] = s.Group4
	s.fieldMap["group5"] = s.Group5
	s.fieldMap["last_udate"] = s.LastUdate
}

func (s seatPowerSetting) clone(db *gorm.DB) seatPowerSetting {
	s.seatPowerSettingDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s seatPowerSetting) replaceDB(db *gorm.DB) seatPowerSetting {
	s.seatPowerSettingDo.ReplaceDB(db)
	return s
}

type seatPowerSettingDo struct{ gen.DO }

type ISeatPowerSettingDo interface {
	gen.SubQuery
	Debug() ISeatPowerSettingDo
	WithContext(ctx context.Context) ISeatPowerSettingDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISeatPowerSettingDo
	WriteDB() ISeatPowerSettingDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISeatPowerSettingDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISeatPowerSettingDo
	Not(conds ...gen.Condition) ISeatPowerSettingDo
	Or(conds ...gen.Condition) ISeatPowerSettingDo
	Select(conds ...field.Expr) ISeatPowerSettingDo
	Where(conds ...gen.Condition) ISeatPowerSettingDo
	Order(conds ...field.Expr) ISeatPowerSettingDo
	Distinct(cols ...field.Expr) ISeatPowerSettingDo
	Omit(cols ...field.Expr) ISeatPowerSettingDo
	Join(table schema.Tabler, on ...field.Expr) ISeatPowerSettingDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISeatPowerSettingDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISeatPowerSettingDo
	Group(cols ...field.Expr) ISeatPowerSettingDo
	Having(conds ...gen.Condition) ISeatPowerSettingDo
	Limit(limit int) ISeatPowerSettingDo
	Offset(offset int) ISeatPowerSettingDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISeatPowerSettingDo
	Unscoped() ISeatPowerSettingDo
	Create(values ...*model.SeatPowerSetting) error
	CreateInBatches(values []*model.SeatPowerSetting, batchSize int) error
	Save(values ...*model.SeatPowerSetting) error
	First() (*model.SeatPowerSetting, error)
	Take() (*model.SeatPowerSetting, error)
	Last() (*model.SeatPowerSetting, error)
	Find() ([]*model.SeatPowerSetting, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SeatPowerSetting, err error)
	FindInBatches(result *[]*model.SeatPowerSetting, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SeatPowerSetting) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISeatPowerSettingDo
	Assign(attrs ...field.AssignExpr) ISeatPowerSettingDo
	Joins(fields ...field.RelationField) ISeatPowerSettingDo
	Preload(fields ...field.RelationField) ISeatPowerSettingDo
	FirstOrInit() (*model.SeatPowerSetting, error)
	FirstOrCreate() (*model.SeatPowerSetting, error)
	FindByPage(offset int, limit int) (result []*model.SeatPowerSetting, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISeatPowerSettingDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s seatPowerSettingDo) Debug() ISeatPowerSettingDo {
	return s.withDO(s.DO.Debug())
}

func (s seatPowerSettingDo) WithContext(ctx context.Context) ISeatPowerSettingDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s seatPowerSettingDo) ReadDB() ISeatPowerSettingDo {
	return s.Clauses(dbresolver.Read)
}

func (s seatPowerSettingDo) WriteDB() ISeatPowerSettingDo {
	return s.Clauses(dbresolver.Write)
}

func (s seatPowerSettingDo) Session(config *gorm.Session) ISeatPowerSettingDo {
	return s.withDO(s.DO.Session(config))
}

func (s seatPowerSettingDo) Clauses(conds ...clause.Expression) ISeatPowerSettingDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s seatPowerSettingDo) Returning(value interface{}, columns ...string) ISeatPowerSettingDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s seatPowerSettingDo) Not(conds ...gen.Condition) ISeatPowerSettingDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s seatPowerSettingDo) Or(conds ...gen.Condition) ISeatPowerSettingDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s seatPowerSettingDo) Select(conds ...field.Expr) ISeatPowerSettingDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s seatPowerSettingDo) Where(conds ...gen.Condition) ISeatPowerSettingDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s seatPowerSettingDo) Order(conds ...field.Expr) ISeatPowerSettingDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s seatPowerSettingDo) Distinct(cols ...field.Expr) ISeatPowerSettingDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s seatPowerSettingDo) Omit(cols ...field.Expr) ISeatPowerSettingDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s seatPowerSettingDo) Join(table schema.Tabler, on ...field.Expr) ISeatPowerSettingDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s seatPowerSettingDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISeatPowerSettingDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s seatPowerSettingDo) RightJoin(table schema.Tabler, on ...field.Expr) ISeatPowerSettingDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s seatPowerSettingDo) Group(cols ...field.Expr) ISeatPowerSettingDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s seatPowerSettingDo) Having(conds ...gen.Condition) ISeatPowerSettingDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s seatPowerSettingDo) Limit(limit int) ISeatPowerSettingDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s seatPowerSettingDo) Offset(offset int) ISeatPowerSettingDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s seatPowerSettingDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISeatPowerSettingDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s seatPowerSettingDo) Unscoped() ISeatPowerSettingDo {
	return s.withDO(s.DO.Unscoped())
}

func (s seatPowerSettingDo) Create(values ...*model.SeatPowerSetting) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s seatPowerSettingDo) CreateInBatches(values []*model.SeatPowerSetting, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s seatPowerSettingDo) Save(values ...*model.SeatPowerSetting) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s seatPowerSettingDo) First() (*model.SeatPowerSetting, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatPowerSetting), nil
	}
}

func (s seatPowerSettingDo) Take() (*model.SeatPowerSetting, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatPowerSetting), nil
	}
}

func (s seatPowerSettingDo) Last() (*model.SeatPowerSetting, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatPowerSetting), nil
	}
}

func (s seatPowerSettingDo) Find() ([]*model.SeatPowerSetting, error) {
	result, err := s.DO.Find()
	return result.([]*model.SeatPowerSetting), err
}

func (s seatPowerSettingDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SeatPowerSetting, err error) {
	buf := make([]*model.SeatPowerSetting, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s seatPowerSettingDo) FindInBatches(result *[]*model.SeatPowerSetting, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s seatPowerSettingDo) Attrs(attrs ...field.AssignExpr) ISeatPowerSettingDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s seatPowerSettingDo) Assign(attrs ...field.AssignExpr) ISeatPowerSettingDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s seatPowerSettingDo) Joins(fields ...field.RelationField) ISeatPowerSettingDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s seatPowerSettingDo) Preload(fields ...field.RelationField) ISeatPowerSettingDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s seatPowerSettingDo) FirstOrInit() (*model.SeatPowerSetting, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatPowerSetting), nil
	}
}

func (s seatPowerSettingDo) FirstOrCreate() (*model.SeatPowerSetting, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatPowerSetting), nil
	}
}

func (s seatPowerSettingDo) FindByPage(offset int, limit int) (result []*model.SeatPowerSetting, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s seatPowerSettingDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s seatPowerSettingDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s seatPowerSettingDo) Delete(models ...*model.SeatPowerSetting) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *seatPowerSettingDo) withDO(do gen.Dao) *seatPowerSettingDo {
	s.DO = *do.(*gen.DO)
	return s
}
