// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newMOBILEBTNOPT(db *gorm.DB, opts ...gen.DOOption) mOBILEBTNOPT {
	_mOBILEBTNOPT := mOBILEBTNOPT{}

	_mOBILEBTNOPT.mOBILEBTNOPTDo.UseDB(db, opts...)
	_mOBILEBTNOPT.mOBILEBTNOPTDo.UseModel(&model.MOBILEBTNOPT{})

	tableName := _mOBILEBTNOPT.mOBILEBTNOPTDo.TableName()
	_mOBILEBTNOPT.ALL = field.NewAsterisk(tableName)
	_mOBILEBTNOPT.ID = field.NewInt64(tableName, "ID")
	_mOBILEBTNOPT.SEATASSIGN = field.NewInt64(tableName, "SEAT_ASSIGN")
	_mOBILEBTNOPT.SEATBOOKING = field.NewInt64(tableName, "SEAT_BOOKING")
	_mOBILEBTNOPT.GROUPBOOKING = field.NewInt64(tableName, "GROUP_BOOKING")
	_mOBILEBTNOPT.BOOKINGCHECK = field.NewInt64(tableName, "BOOKING_CHECK")
	_mOBILEBTNOPT.ALARM = field.NewInt64(tableName, "ALARM")
	_mOBILEBTNOPT.NFC = field.NewInt64(tableName, "NFC")
	_mOBILEBTNOPT.QR = field.NewInt64(tableName, "QR")

	_mOBILEBTNOPT.fillFieldMap()

	return _mOBILEBTNOPT
}

type mOBILEBTNOPT struct {
	mOBILEBTNOPTDo

	ALL          field.Asterisk
	ID           field.Int64
	SEATASSIGN   field.Int64
	SEATBOOKING  field.Int64
	GROUPBOOKING field.Int64
	BOOKINGCHECK field.Int64
	ALARM        field.Int64
	NFC          field.Int64
	QR           field.Int64

	fieldMap map[string]field.Expr
}

func (m mOBILEBTNOPT) Table(newTableName string) *mOBILEBTNOPT {
	m.mOBILEBTNOPTDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m mOBILEBTNOPT) As(alias string) *mOBILEBTNOPT {
	m.mOBILEBTNOPTDo.DO = *(m.mOBILEBTNOPTDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *mOBILEBTNOPT) updateTableName(table string) *mOBILEBTNOPT {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt64(table, "ID")
	m.SEATASSIGN = field.NewInt64(table, "SEAT_ASSIGN")
	m.SEATBOOKING = field.NewInt64(table, "SEAT_BOOKING")
	m.GROUPBOOKING = field.NewInt64(table, "GROUP_BOOKING")
	m.BOOKINGCHECK = field.NewInt64(table, "BOOKING_CHECK")
	m.ALARM = field.NewInt64(table, "ALARM")
	m.NFC = field.NewInt64(table, "NFC")
	m.QR = field.NewInt64(table, "QR")

	m.fillFieldMap()

	return m
}

func (m *mOBILEBTNOPT) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *mOBILEBTNOPT) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 8)
	m.fieldMap["ID"] = m.ID
	m.fieldMap["SEAT_ASSIGN"] = m.SEATASSIGN
	m.fieldMap["SEAT_BOOKING"] = m.SEATBOOKING
	m.fieldMap["GROUP_BOOKING"] = m.GROUPBOOKING
	m.fieldMap["BOOKING_CHECK"] = m.BOOKINGCHECK
	m.fieldMap["ALARM"] = m.ALARM
	m.fieldMap["NFC"] = m.NFC
	m.fieldMap["QR"] = m.QR
}

func (m mOBILEBTNOPT) clone(db *gorm.DB) mOBILEBTNOPT {
	m.mOBILEBTNOPTDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m mOBILEBTNOPT) replaceDB(db *gorm.DB) mOBILEBTNOPT {
	m.mOBILEBTNOPTDo.ReplaceDB(db)
	return m
}

type mOBILEBTNOPTDo struct{ gen.DO }

type IMOBILEBTNOPTDo interface {
	gen.SubQuery
	Debug() IMOBILEBTNOPTDo
	WithContext(ctx context.Context) IMOBILEBTNOPTDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMOBILEBTNOPTDo
	WriteDB() IMOBILEBTNOPTDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMOBILEBTNOPTDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMOBILEBTNOPTDo
	Not(conds ...gen.Condition) IMOBILEBTNOPTDo
	Or(conds ...gen.Condition) IMOBILEBTNOPTDo
	Select(conds ...field.Expr) IMOBILEBTNOPTDo
	Where(conds ...gen.Condition) IMOBILEBTNOPTDo
	Order(conds ...field.Expr) IMOBILEBTNOPTDo
	Distinct(cols ...field.Expr) IMOBILEBTNOPTDo
	Omit(cols ...field.Expr) IMOBILEBTNOPTDo
	Join(table schema.Tabler, on ...field.Expr) IMOBILEBTNOPTDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMOBILEBTNOPTDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMOBILEBTNOPTDo
	Group(cols ...field.Expr) IMOBILEBTNOPTDo
	Having(conds ...gen.Condition) IMOBILEBTNOPTDo
	Limit(limit int) IMOBILEBTNOPTDo
	Offset(offset int) IMOBILEBTNOPTDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMOBILEBTNOPTDo
	Unscoped() IMOBILEBTNOPTDo
	Create(values ...*model.MOBILEBTNOPT) error
	CreateInBatches(values []*model.MOBILEBTNOPT, batchSize int) error
	Save(values ...*model.MOBILEBTNOPT) error
	First() (*model.MOBILEBTNOPT, error)
	Take() (*model.MOBILEBTNOPT, error)
	Last() (*model.MOBILEBTNOPT, error)
	Find() ([]*model.MOBILEBTNOPT, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MOBILEBTNOPT, err error)
	FindInBatches(result *[]*model.MOBILEBTNOPT, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MOBILEBTNOPT) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMOBILEBTNOPTDo
	Assign(attrs ...field.AssignExpr) IMOBILEBTNOPTDo
	Joins(fields ...field.RelationField) IMOBILEBTNOPTDo
	Preload(fields ...field.RelationField) IMOBILEBTNOPTDo
	FirstOrInit() (*model.MOBILEBTNOPT, error)
	FirstOrCreate() (*model.MOBILEBTNOPT, error)
	FindByPage(offset int, limit int) (result []*model.MOBILEBTNOPT, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMOBILEBTNOPTDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m mOBILEBTNOPTDo) Debug() IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Debug())
}

func (m mOBILEBTNOPTDo) WithContext(ctx context.Context) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m mOBILEBTNOPTDo) ReadDB() IMOBILEBTNOPTDo {
	return m.Clauses(dbresolver.Read)
}

func (m mOBILEBTNOPTDo) WriteDB() IMOBILEBTNOPTDo {
	return m.Clauses(dbresolver.Write)
}

func (m mOBILEBTNOPTDo) Session(config *gorm.Session) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Session(config))
}

func (m mOBILEBTNOPTDo) Clauses(conds ...clause.Expression) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m mOBILEBTNOPTDo) Returning(value interface{}, columns ...string) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m mOBILEBTNOPTDo) Not(conds ...gen.Condition) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m mOBILEBTNOPTDo) Or(conds ...gen.Condition) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m mOBILEBTNOPTDo) Select(conds ...field.Expr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m mOBILEBTNOPTDo) Where(conds ...gen.Condition) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m mOBILEBTNOPTDo) Order(conds ...field.Expr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m mOBILEBTNOPTDo) Distinct(cols ...field.Expr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m mOBILEBTNOPTDo) Omit(cols ...field.Expr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m mOBILEBTNOPTDo) Join(table schema.Tabler, on ...field.Expr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m mOBILEBTNOPTDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m mOBILEBTNOPTDo) RightJoin(table schema.Tabler, on ...field.Expr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m mOBILEBTNOPTDo) Group(cols ...field.Expr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m mOBILEBTNOPTDo) Having(conds ...gen.Condition) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m mOBILEBTNOPTDo) Limit(limit int) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m mOBILEBTNOPTDo) Offset(offset int) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m mOBILEBTNOPTDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m mOBILEBTNOPTDo) Unscoped() IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Unscoped())
}

func (m mOBILEBTNOPTDo) Create(values ...*model.MOBILEBTNOPT) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m mOBILEBTNOPTDo) CreateInBatches(values []*model.MOBILEBTNOPT, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m mOBILEBTNOPTDo) Save(values ...*model.MOBILEBTNOPT) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m mOBILEBTNOPTDo) First() (*model.MOBILEBTNOPT, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MOBILEBTNOPT), nil
	}
}

func (m mOBILEBTNOPTDo) Take() (*model.MOBILEBTNOPT, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MOBILEBTNOPT), nil
	}
}

func (m mOBILEBTNOPTDo) Last() (*model.MOBILEBTNOPT, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MOBILEBTNOPT), nil
	}
}

func (m mOBILEBTNOPTDo) Find() ([]*model.MOBILEBTNOPT, error) {
	result, err := m.DO.Find()
	return result.([]*model.MOBILEBTNOPT), err
}

func (m mOBILEBTNOPTDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MOBILEBTNOPT, err error) {
	buf := make([]*model.MOBILEBTNOPT, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m mOBILEBTNOPTDo) FindInBatches(result *[]*model.MOBILEBTNOPT, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m mOBILEBTNOPTDo) Attrs(attrs ...field.AssignExpr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m mOBILEBTNOPTDo) Assign(attrs ...field.AssignExpr) IMOBILEBTNOPTDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m mOBILEBTNOPTDo) Joins(fields ...field.RelationField) IMOBILEBTNOPTDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m mOBILEBTNOPTDo) Preload(fields ...field.RelationField) IMOBILEBTNOPTDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m mOBILEBTNOPTDo) FirstOrInit() (*model.MOBILEBTNOPT, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MOBILEBTNOPT), nil
	}
}

func (m mOBILEBTNOPTDo) FirstOrCreate() (*model.MOBILEBTNOPT, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MOBILEBTNOPT), nil
	}
}

func (m mOBILEBTNOPTDo) FindByPage(offset int, limit int) (result []*model.MOBILEBTNOPT, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m mOBILEBTNOPTDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m mOBILEBTNOPTDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m mOBILEBTNOPTDo) Delete(models ...*model.MOBILEBTNOPT) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *mOBILEBTNOPTDo) withDO(do gen.Dao) *mOBILEBTNOPTDo {
	m.DO = *do.(*gen.DO)
	return m
}
