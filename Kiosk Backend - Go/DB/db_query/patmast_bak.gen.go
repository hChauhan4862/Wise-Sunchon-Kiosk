// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newPATMASTBAK(db *gorm.DB, opts ...gen.DOOption) pATMASTBAK {
	_pATMASTBAK := pATMASTBAK{}

	_pATMASTBAK.pATMASTBAKDo.UseDB(db, opts...)
	_pATMASTBAK.pATMASTBAKDo.UseModel(&model.PATMASTBAK{})

	tableName := _pATMASTBAK.pATMASTBAKDo.TableName()
	_pATMASTBAK.ALL = field.NewAsterisk(tableName)
	_pATMASTBAK.AltPid = field.NewString(tableName, "alt_pid")
	_pATMASTBAK.Username = field.NewString(tableName, "username")
	_pATMASTBAK.PatType = field.NewString(tableName, "pat_type")
	_pATMASTBAK.PatName = field.NewString(tableName, "pat_name")
	_pATMASTBAK.DeptCode = field.NewString(tableName, "dept_code")
	_pATMASTBAK.DeptName = field.NewString(tableName, "dept_name")
	_pATMASTBAK.CollegeCode = field.NewString(tableName, "college_code")
	_pATMASTBAK.CollegeName = field.NewString(tableName, "college_name")
	_pATMASTBAK.Phone3 = field.NewString(tableName, "phone3")
	_pATMASTBAK.Email = field.NewString(tableName, "email")
	_pATMASTBAK.DateExprd = field.NewString(tableName, "date_exprd")
	_pATMASTBAK.PatStat = field.NewString(tableName, "pat_stat")

	_pATMASTBAK.fillFieldMap()

	return _pATMASTBAK
}

type pATMASTBAK struct {
	pATMASTBAKDo

	ALL         field.Asterisk
	AltPid      field.String
	Username    field.String
	PatType     field.String
	PatName     field.String
	DeptCode    field.String
	DeptName    field.String
	CollegeCode field.String
	CollegeName field.String
	Phone3      field.String
	Email       field.String
	DateExprd   field.String
	PatStat     field.String

	fieldMap map[string]field.Expr
}

func (p pATMASTBAK) Table(newTableName string) *pATMASTBAK {
	p.pATMASTBAKDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p pATMASTBAK) As(alias string) *pATMASTBAK {
	p.pATMASTBAKDo.DO = *(p.pATMASTBAKDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *pATMASTBAK) updateTableName(table string) *pATMASTBAK {
	p.ALL = field.NewAsterisk(table)
	p.AltPid = field.NewString(table, "alt_pid")
	p.Username = field.NewString(table, "username")
	p.PatType = field.NewString(table, "pat_type")
	p.PatName = field.NewString(table, "pat_name")
	p.DeptCode = field.NewString(table, "dept_code")
	p.DeptName = field.NewString(table, "dept_name")
	p.CollegeCode = field.NewString(table, "college_code")
	p.CollegeName = field.NewString(table, "college_name")
	p.Phone3 = field.NewString(table, "phone3")
	p.Email = field.NewString(table, "email")
	p.DateExprd = field.NewString(table, "date_exprd")
	p.PatStat = field.NewString(table, "pat_stat")

	p.fillFieldMap()

	return p
}

func (p *pATMASTBAK) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *pATMASTBAK) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 12)
	p.fieldMap["alt_pid"] = p.AltPid
	p.fieldMap["username"] = p.Username
	p.fieldMap["pat_type"] = p.PatType
	p.fieldMap["pat_name"] = p.PatName
	p.fieldMap["dept_code"] = p.DeptCode
	p.fieldMap["dept_name"] = p.DeptName
	p.fieldMap["college_code"] = p.CollegeCode
	p.fieldMap["college_name"] = p.CollegeName
	p.fieldMap["phone3"] = p.Phone3
	p.fieldMap["email"] = p.Email
	p.fieldMap["date_exprd"] = p.DateExprd
	p.fieldMap["pat_stat"] = p.PatStat
}

func (p pATMASTBAK) clone(db *gorm.DB) pATMASTBAK {
	p.pATMASTBAKDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p pATMASTBAK) replaceDB(db *gorm.DB) pATMASTBAK {
	p.pATMASTBAKDo.ReplaceDB(db)
	return p
}

type pATMASTBAKDo struct{ gen.DO }

type IPATMASTBAKDo interface {
	gen.SubQuery
	Debug() IPATMASTBAKDo
	WithContext(ctx context.Context) IPATMASTBAKDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPATMASTBAKDo
	WriteDB() IPATMASTBAKDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPATMASTBAKDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPATMASTBAKDo
	Not(conds ...gen.Condition) IPATMASTBAKDo
	Or(conds ...gen.Condition) IPATMASTBAKDo
	Select(conds ...field.Expr) IPATMASTBAKDo
	Where(conds ...gen.Condition) IPATMASTBAKDo
	Order(conds ...field.Expr) IPATMASTBAKDo
	Distinct(cols ...field.Expr) IPATMASTBAKDo
	Omit(cols ...field.Expr) IPATMASTBAKDo
	Join(table schema.Tabler, on ...field.Expr) IPATMASTBAKDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPATMASTBAKDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPATMASTBAKDo
	Group(cols ...field.Expr) IPATMASTBAKDo
	Having(conds ...gen.Condition) IPATMASTBAKDo
	Limit(limit int) IPATMASTBAKDo
	Offset(offset int) IPATMASTBAKDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPATMASTBAKDo
	Unscoped() IPATMASTBAKDo
	Create(values ...*model.PATMASTBAK) error
	CreateInBatches(values []*model.PATMASTBAK, batchSize int) error
	Save(values ...*model.PATMASTBAK) error
	First() (*model.PATMASTBAK, error)
	Take() (*model.PATMASTBAK, error)
	Last() (*model.PATMASTBAK, error)
	Find() ([]*model.PATMASTBAK, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PATMASTBAK, err error)
	FindInBatches(result *[]*model.PATMASTBAK, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PATMASTBAK) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPATMASTBAKDo
	Assign(attrs ...field.AssignExpr) IPATMASTBAKDo
	Joins(fields ...field.RelationField) IPATMASTBAKDo
	Preload(fields ...field.RelationField) IPATMASTBAKDo
	FirstOrInit() (*model.PATMASTBAK, error)
	FirstOrCreate() (*model.PATMASTBAK, error)
	FindByPage(offset int, limit int) (result []*model.PATMASTBAK, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPATMASTBAKDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p pATMASTBAKDo) Debug() IPATMASTBAKDo {
	return p.withDO(p.DO.Debug())
}

func (p pATMASTBAKDo) WithContext(ctx context.Context) IPATMASTBAKDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p pATMASTBAKDo) ReadDB() IPATMASTBAKDo {
	return p.Clauses(dbresolver.Read)
}

func (p pATMASTBAKDo) WriteDB() IPATMASTBAKDo {
	return p.Clauses(dbresolver.Write)
}

func (p pATMASTBAKDo) Session(config *gorm.Session) IPATMASTBAKDo {
	return p.withDO(p.DO.Session(config))
}

func (p pATMASTBAKDo) Clauses(conds ...clause.Expression) IPATMASTBAKDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p pATMASTBAKDo) Returning(value interface{}, columns ...string) IPATMASTBAKDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p pATMASTBAKDo) Not(conds ...gen.Condition) IPATMASTBAKDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p pATMASTBAKDo) Or(conds ...gen.Condition) IPATMASTBAKDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p pATMASTBAKDo) Select(conds ...field.Expr) IPATMASTBAKDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p pATMASTBAKDo) Where(conds ...gen.Condition) IPATMASTBAKDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p pATMASTBAKDo) Order(conds ...field.Expr) IPATMASTBAKDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p pATMASTBAKDo) Distinct(cols ...field.Expr) IPATMASTBAKDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p pATMASTBAKDo) Omit(cols ...field.Expr) IPATMASTBAKDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p pATMASTBAKDo) Join(table schema.Tabler, on ...field.Expr) IPATMASTBAKDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p pATMASTBAKDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPATMASTBAKDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p pATMASTBAKDo) RightJoin(table schema.Tabler, on ...field.Expr) IPATMASTBAKDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p pATMASTBAKDo) Group(cols ...field.Expr) IPATMASTBAKDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p pATMASTBAKDo) Having(conds ...gen.Condition) IPATMASTBAKDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p pATMASTBAKDo) Limit(limit int) IPATMASTBAKDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p pATMASTBAKDo) Offset(offset int) IPATMASTBAKDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p pATMASTBAKDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPATMASTBAKDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p pATMASTBAKDo) Unscoped() IPATMASTBAKDo {
	return p.withDO(p.DO.Unscoped())
}

func (p pATMASTBAKDo) Create(values ...*model.PATMASTBAK) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p pATMASTBAKDo) CreateInBatches(values []*model.PATMASTBAK, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p pATMASTBAKDo) Save(values ...*model.PATMASTBAK) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p pATMASTBAKDo) First() (*model.PATMASTBAK, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMASTBAK), nil
	}
}

func (p pATMASTBAKDo) Take() (*model.PATMASTBAK, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMASTBAK), nil
	}
}

func (p pATMASTBAKDo) Last() (*model.PATMASTBAK, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMASTBAK), nil
	}
}

func (p pATMASTBAKDo) Find() ([]*model.PATMASTBAK, error) {
	result, err := p.DO.Find()
	return result.([]*model.PATMASTBAK), err
}

func (p pATMASTBAKDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PATMASTBAK, err error) {
	buf := make([]*model.PATMASTBAK, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p pATMASTBAKDo) FindInBatches(result *[]*model.PATMASTBAK, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p pATMASTBAKDo) Attrs(attrs ...field.AssignExpr) IPATMASTBAKDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p pATMASTBAKDo) Assign(attrs ...field.AssignExpr) IPATMASTBAKDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p pATMASTBAKDo) Joins(fields ...field.RelationField) IPATMASTBAKDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p pATMASTBAKDo) Preload(fields ...field.RelationField) IPATMASTBAKDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p pATMASTBAKDo) FirstOrInit() (*model.PATMASTBAK, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMASTBAK), nil
	}
}

func (p pATMASTBAKDo) FirstOrCreate() (*model.PATMASTBAK, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PATMASTBAK), nil
	}
}

func (p pATMASTBAKDo) FindByPage(offset int, limit int) (result []*model.PATMASTBAK, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p pATMASTBAKDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p pATMASTBAKDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p pATMASTBAKDo) Delete(models ...*model.PATMASTBAK) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *pATMASTBAKDo) withDO(do gen.Dao) *pATMASTBAKDo {
	p.DO = *do.(*gen.DO)
	return p
}
