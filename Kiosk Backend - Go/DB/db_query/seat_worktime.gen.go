// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newSeatWorktime(db *gorm.DB, opts ...gen.DOOption) seatWorktime {
	_seatWorktime := seatWorktime{}

	_seatWorktime.seatWorktimeDo.UseDB(db, opts...)
	_seatWorktime.seatWorktimeDo.UseModel(&model.SeatWorktime{})

	tableName := _seatWorktime.seatWorktimeDo.TableName()
	_seatWorktime.ALL = field.NewAsterisk(tableName)
	_seatWorktime.WSEQNO = field.NewInt64(tableName, "WSEQNO")
	_seatWorktime.TITLE = field.NewString(tableName, "TITLE")
	_seatWorktime.OPENTIME1 = field.NewInt64(tableName, "OPENTIME_1")
	_seatWorktime.CLOSETIME1 = field.NewInt64(tableName, "CLOSETIME_1")
	_seatWorktime.OPENTIME2 = field.NewInt64(tableName, "OPENTIME_2")
	_seatWorktime.CLOSETIME2 = field.NewInt64(tableName, "CLOSETIME_2")
	_seatWorktime.OPENTIME3 = field.NewInt64(tableName, "OPENTIME_3")
	_seatWorktime.CLOSETIME3 = field.NewInt64(tableName, "CLOSETIME_3")
	_seatWorktime.OPENTIME4 = field.NewInt64(tableName, "OPENTIME_4")
	_seatWorktime.CLOSETIME4 = field.NewInt64(tableName, "CLOSETIME_4")
	_seatWorktime.OPENTIME5 = field.NewInt64(tableName, "OPENTIME_5")
	_seatWorktime.CLOSETIME5 = field.NewInt64(tableName, "CLOSETIME_5")
	_seatWorktime.OPENTIME6 = field.NewInt64(tableName, "OPENTIME_6")
	_seatWorktime.CLOSETIME6 = field.NewInt64(tableName, "CLOSETIME_6")
	_seatWorktime.OPENTIME7 = field.NewInt64(tableName, "OPENTIME_7")
	_seatWorktime.CLOSETIME7 = field.NewInt64(tableName, "CLOSETIME_7")
	_seatWorktime.OPENTIME8 = field.NewInt64(tableName, "OPENTIME_8")
	_seatWorktime.CLOSETIME8 = field.NewInt64(tableName, "CLOSETIME_8")
	_seatWorktime.OPENTIME9 = field.NewInt64(tableName, "OPENTIME_9")
	_seatWorktime.CLOSETIME9 = field.NewInt64(tableName, "CLOSETIME_9")
	_seatWorktime.OPENTIME10 = field.NewInt64(tableName, "OPENTIME_10")
	_seatWorktime.CLOSETIME10 = field.NewInt64(tableName, "CLOSETIME_10")
	_seatWorktime.OPENTIME11 = field.NewInt64(tableName, "OPENTIME_11")
	_seatWorktime.CLOSETIME11 = field.NewInt64(tableName, "CLOSETIME_11")
	_seatWorktime.OPENTIME12 = field.NewInt64(tableName, "OPENTIME_12")
	_seatWorktime.CLOSETIME12 = field.NewInt64(tableName, "CLOSETIME_12")

	_seatWorktime.fillFieldMap()

	return _seatWorktime
}

type seatWorktime struct {
	seatWorktimeDo

	ALL         field.Asterisk
	WSEQNO      field.Int64
	TITLE       field.String
	OPENTIME1   field.Int64
	CLOSETIME1  field.Int64
	OPENTIME2   field.Int64
	CLOSETIME2  field.Int64
	OPENTIME3   field.Int64
	CLOSETIME3  field.Int64
	OPENTIME4   field.Int64
	CLOSETIME4  field.Int64
	OPENTIME5   field.Int64
	CLOSETIME5  field.Int64
	OPENTIME6   field.Int64
	CLOSETIME6  field.Int64
	OPENTIME7   field.Int64
	CLOSETIME7  field.Int64
	OPENTIME8   field.Int64
	CLOSETIME8  field.Int64
	OPENTIME9   field.Int64
	CLOSETIME9  field.Int64
	OPENTIME10  field.Int64
	CLOSETIME10 field.Int64
	OPENTIME11  field.Int64
	CLOSETIME11 field.Int64
	OPENTIME12  field.Int64
	CLOSETIME12 field.Int64

	fieldMap map[string]field.Expr
}

func (s seatWorktime) Table(newTableName string) *seatWorktime {
	s.seatWorktimeDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s seatWorktime) As(alias string) *seatWorktime {
	s.seatWorktimeDo.DO = *(s.seatWorktimeDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *seatWorktime) updateTableName(table string) *seatWorktime {
	s.ALL = field.NewAsterisk(table)
	s.WSEQNO = field.NewInt64(table, "WSEQNO")
	s.TITLE = field.NewString(table, "TITLE")
	s.OPENTIME1 = field.NewInt64(table, "OPENTIME_1")
	s.CLOSETIME1 = field.NewInt64(table, "CLOSETIME_1")
	s.OPENTIME2 = field.NewInt64(table, "OPENTIME_2")
	s.CLOSETIME2 = field.NewInt64(table, "CLOSETIME_2")
	s.OPENTIME3 = field.NewInt64(table, "OPENTIME_3")
	s.CLOSETIME3 = field.NewInt64(table, "CLOSETIME_3")
	s.OPENTIME4 = field.NewInt64(table, "OPENTIME_4")
	s.CLOSETIME4 = field.NewInt64(table, "CLOSETIME_4")
	s.OPENTIME5 = field.NewInt64(table, "OPENTIME_5")
	s.CLOSETIME5 = field.NewInt64(table, "CLOSETIME_5")
	s.OPENTIME6 = field.NewInt64(table, "OPENTIME_6")
	s.CLOSETIME6 = field.NewInt64(table, "CLOSETIME_6")
	s.OPENTIME7 = field.NewInt64(table, "OPENTIME_7")
	s.CLOSETIME7 = field.NewInt64(table, "CLOSETIME_7")
	s.OPENTIME8 = field.NewInt64(table, "OPENTIME_8")
	s.CLOSETIME8 = field.NewInt64(table, "CLOSETIME_8")
	s.OPENTIME9 = field.NewInt64(table, "OPENTIME_9")
	s.CLOSETIME9 = field.NewInt64(table, "CLOSETIME_9")
	s.OPENTIME10 = field.NewInt64(table, "OPENTIME_10")
	s.CLOSETIME10 = field.NewInt64(table, "CLOSETIME_10")
	s.OPENTIME11 = field.NewInt64(table, "OPENTIME_11")
	s.CLOSETIME11 = field.NewInt64(table, "CLOSETIME_11")
	s.OPENTIME12 = field.NewInt64(table, "OPENTIME_12")
	s.CLOSETIME12 = field.NewInt64(table, "CLOSETIME_12")

	s.fillFieldMap()

	return s
}

func (s *seatWorktime) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *seatWorktime) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 26)
	s.fieldMap["WSEQNO"] = s.WSEQNO
	s.fieldMap["TITLE"] = s.TITLE
	s.fieldMap["OPENTIME_1"] = s.OPENTIME1
	s.fieldMap["CLOSETIME_1"] = s.CLOSETIME1
	s.fieldMap["OPENTIME_2"] = s.OPENTIME2
	s.fieldMap["CLOSETIME_2"] = s.CLOSETIME2
	s.fieldMap["OPENTIME_3"] = s.OPENTIME3
	s.fieldMap["CLOSETIME_3"] = s.CLOSETIME3
	s.fieldMap["OPENTIME_4"] = s.OPENTIME4
	s.fieldMap["CLOSETIME_4"] = s.CLOSETIME4
	s.fieldMap["OPENTIME_5"] = s.OPENTIME5
	s.fieldMap["CLOSETIME_5"] = s.CLOSETIME5
	s.fieldMap["OPENTIME_6"] = s.OPENTIME6
	s.fieldMap["CLOSETIME_6"] = s.CLOSETIME6
	s.fieldMap["OPENTIME_7"] = s.OPENTIME7
	s.fieldMap["CLOSETIME_7"] = s.CLOSETIME7
	s.fieldMap["OPENTIME_8"] = s.OPENTIME8
	s.fieldMap["CLOSETIME_8"] = s.CLOSETIME8
	s.fieldMap["OPENTIME_9"] = s.OPENTIME9
	s.fieldMap["CLOSETIME_9"] = s.CLOSETIME9
	s.fieldMap["OPENTIME_10"] = s.OPENTIME10
	s.fieldMap["CLOSETIME_10"] = s.CLOSETIME10
	s.fieldMap["OPENTIME_11"] = s.OPENTIME11
	s.fieldMap["CLOSETIME_11"] = s.CLOSETIME11
	s.fieldMap["OPENTIME_12"] = s.OPENTIME12
	s.fieldMap["CLOSETIME_12"] = s.CLOSETIME12
}

func (s seatWorktime) clone(db *gorm.DB) seatWorktime {
	s.seatWorktimeDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s seatWorktime) replaceDB(db *gorm.DB) seatWorktime {
	s.seatWorktimeDo.ReplaceDB(db)
	return s
}

type seatWorktimeDo struct{ gen.DO }

type ISeatWorktimeDo interface {
	gen.SubQuery
	Debug() ISeatWorktimeDo
	WithContext(ctx context.Context) ISeatWorktimeDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISeatWorktimeDo
	WriteDB() ISeatWorktimeDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISeatWorktimeDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISeatWorktimeDo
	Not(conds ...gen.Condition) ISeatWorktimeDo
	Or(conds ...gen.Condition) ISeatWorktimeDo
	Select(conds ...field.Expr) ISeatWorktimeDo
	Where(conds ...gen.Condition) ISeatWorktimeDo
	Order(conds ...field.Expr) ISeatWorktimeDo
	Distinct(cols ...field.Expr) ISeatWorktimeDo
	Omit(cols ...field.Expr) ISeatWorktimeDo
	Join(table schema.Tabler, on ...field.Expr) ISeatWorktimeDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISeatWorktimeDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISeatWorktimeDo
	Group(cols ...field.Expr) ISeatWorktimeDo
	Having(conds ...gen.Condition) ISeatWorktimeDo
	Limit(limit int) ISeatWorktimeDo
	Offset(offset int) ISeatWorktimeDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISeatWorktimeDo
	Unscoped() ISeatWorktimeDo
	Create(values ...*model.SeatWorktime) error
	CreateInBatches(values []*model.SeatWorktime, batchSize int) error
	Save(values ...*model.SeatWorktime) error
	First() (*model.SeatWorktime, error)
	Take() (*model.SeatWorktime, error)
	Last() (*model.SeatWorktime, error)
	Find() ([]*model.SeatWorktime, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SeatWorktime, err error)
	FindInBatches(result *[]*model.SeatWorktime, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SeatWorktime) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISeatWorktimeDo
	Assign(attrs ...field.AssignExpr) ISeatWorktimeDo
	Joins(fields ...field.RelationField) ISeatWorktimeDo
	Preload(fields ...field.RelationField) ISeatWorktimeDo
	FirstOrInit() (*model.SeatWorktime, error)
	FirstOrCreate() (*model.SeatWorktime, error)
	FindByPage(offset int, limit int) (result []*model.SeatWorktime, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISeatWorktimeDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s seatWorktimeDo) Debug() ISeatWorktimeDo {
	return s.withDO(s.DO.Debug())
}

func (s seatWorktimeDo) WithContext(ctx context.Context) ISeatWorktimeDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s seatWorktimeDo) ReadDB() ISeatWorktimeDo {
	return s.Clauses(dbresolver.Read)
}

func (s seatWorktimeDo) WriteDB() ISeatWorktimeDo {
	return s.Clauses(dbresolver.Write)
}

func (s seatWorktimeDo) Session(config *gorm.Session) ISeatWorktimeDo {
	return s.withDO(s.DO.Session(config))
}

func (s seatWorktimeDo) Clauses(conds ...clause.Expression) ISeatWorktimeDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s seatWorktimeDo) Returning(value interface{}, columns ...string) ISeatWorktimeDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s seatWorktimeDo) Not(conds ...gen.Condition) ISeatWorktimeDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s seatWorktimeDo) Or(conds ...gen.Condition) ISeatWorktimeDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s seatWorktimeDo) Select(conds ...field.Expr) ISeatWorktimeDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s seatWorktimeDo) Where(conds ...gen.Condition) ISeatWorktimeDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s seatWorktimeDo) Order(conds ...field.Expr) ISeatWorktimeDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s seatWorktimeDo) Distinct(cols ...field.Expr) ISeatWorktimeDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s seatWorktimeDo) Omit(cols ...field.Expr) ISeatWorktimeDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s seatWorktimeDo) Join(table schema.Tabler, on ...field.Expr) ISeatWorktimeDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s seatWorktimeDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISeatWorktimeDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s seatWorktimeDo) RightJoin(table schema.Tabler, on ...field.Expr) ISeatWorktimeDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s seatWorktimeDo) Group(cols ...field.Expr) ISeatWorktimeDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s seatWorktimeDo) Having(conds ...gen.Condition) ISeatWorktimeDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s seatWorktimeDo) Limit(limit int) ISeatWorktimeDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s seatWorktimeDo) Offset(offset int) ISeatWorktimeDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s seatWorktimeDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISeatWorktimeDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s seatWorktimeDo) Unscoped() ISeatWorktimeDo {
	return s.withDO(s.DO.Unscoped())
}

func (s seatWorktimeDo) Create(values ...*model.SeatWorktime) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s seatWorktimeDo) CreateInBatches(values []*model.SeatWorktime, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s seatWorktimeDo) Save(values ...*model.SeatWorktime) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s seatWorktimeDo) First() (*model.SeatWorktime, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatWorktime), nil
	}
}

func (s seatWorktimeDo) Take() (*model.SeatWorktime, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatWorktime), nil
	}
}

func (s seatWorktimeDo) Last() (*model.SeatWorktime, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatWorktime), nil
	}
}

func (s seatWorktimeDo) Find() ([]*model.SeatWorktime, error) {
	result, err := s.DO.Find()
	return result.([]*model.SeatWorktime), err
}

func (s seatWorktimeDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SeatWorktime, err error) {
	buf := make([]*model.SeatWorktime, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s seatWorktimeDo) FindInBatches(result *[]*model.SeatWorktime, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s seatWorktimeDo) Attrs(attrs ...field.AssignExpr) ISeatWorktimeDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s seatWorktimeDo) Assign(attrs ...field.AssignExpr) ISeatWorktimeDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s seatWorktimeDo) Joins(fields ...field.RelationField) ISeatWorktimeDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s seatWorktimeDo) Preload(fields ...field.RelationField) ISeatWorktimeDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s seatWorktimeDo) FirstOrInit() (*model.SeatWorktime, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatWorktime), nil
	}
}

func (s seatWorktimeDo) FirstOrCreate() (*model.SeatWorktime, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatWorktime), nil
	}
}

func (s seatWorktimeDo) FindByPage(offset int, limit int) (result []*model.SeatWorktime, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s seatWorktimeDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s seatWorktimeDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s seatWorktimeDo) Delete(models ...*model.SeatWorktime) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *seatWorktimeDo) withDO(do gen.Dao) *seatWorktimeDo {
	s.DO = *do.(*gen.DO)
	return s
}
