// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db_query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"WISE_SOFTWARE/DB/model"
)

func newSeatBookingCancel(db *gorm.DB, opts ...gen.DOOption) seatBookingCancel {
	_seatBookingCancel := seatBookingCancel{}

	_seatBookingCancel.seatBookingCancelDo.UseDB(db, opts...)
	_seatBookingCancel.seatBookingCancelDo.UseModel(&model.SeatBookingCancel{})

	tableName := _seatBookingCancel.seatBookingCancelDo.TableName()
	_seatBookingCancel.ALL = field.NewAsterisk(tableName)
	_seatBookingCancel.BSEQNO = field.NewInt64(tableName, "BSEQNO")
	_seatBookingCancel.CSCHOOLNO = field.NewString(tableName, "CSCHOOLNO")
	_seatBookingCancel.CUSERNAME = field.NewString(tableName, "CUSER_NAME")
	_seatBookingCancel.CBIGO = field.NewString(tableName, "CBIGO")

	_seatBookingCancel.fillFieldMap()

	return _seatBookingCancel
}

type seatBookingCancel struct {
	seatBookingCancelDo

	ALL       field.Asterisk
	BSEQNO    field.Int64
	CSCHOOLNO field.String
	CUSERNAME field.String
	CBIGO     field.String

	fieldMap map[string]field.Expr
}

func (s seatBookingCancel) Table(newTableName string) *seatBookingCancel {
	s.seatBookingCancelDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s seatBookingCancel) As(alias string) *seatBookingCancel {
	s.seatBookingCancelDo.DO = *(s.seatBookingCancelDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *seatBookingCancel) updateTableName(table string) *seatBookingCancel {
	s.ALL = field.NewAsterisk(table)
	s.BSEQNO = field.NewInt64(table, "BSEQNO")
	s.CSCHOOLNO = field.NewString(table, "CSCHOOLNO")
	s.CUSERNAME = field.NewString(table, "CUSER_NAME")
	s.CBIGO = field.NewString(table, "CBIGO")

	s.fillFieldMap()

	return s
}

func (s *seatBookingCancel) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *seatBookingCancel) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 4)
	s.fieldMap["BSEQNO"] = s.BSEQNO
	s.fieldMap["CSCHOOLNO"] = s.CSCHOOLNO
	s.fieldMap["CUSER_NAME"] = s.CUSERNAME
	s.fieldMap["CBIGO"] = s.CBIGO
}

func (s seatBookingCancel) clone(db *gorm.DB) seatBookingCancel {
	s.seatBookingCancelDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s seatBookingCancel) replaceDB(db *gorm.DB) seatBookingCancel {
	s.seatBookingCancelDo.ReplaceDB(db)
	return s
}

type seatBookingCancelDo struct{ gen.DO }

type ISeatBookingCancelDo interface {
	gen.SubQuery
	Debug() ISeatBookingCancelDo
	WithContext(ctx context.Context) ISeatBookingCancelDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISeatBookingCancelDo
	WriteDB() ISeatBookingCancelDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISeatBookingCancelDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISeatBookingCancelDo
	Not(conds ...gen.Condition) ISeatBookingCancelDo
	Or(conds ...gen.Condition) ISeatBookingCancelDo
	Select(conds ...field.Expr) ISeatBookingCancelDo
	Where(conds ...gen.Condition) ISeatBookingCancelDo
	Order(conds ...field.Expr) ISeatBookingCancelDo
	Distinct(cols ...field.Expr) ISeatBookingCancelDo
	Omit(cols ...field.Expr) ISeatBookingCancelDo
	Join(table schema.Tabler, on ...field.Expr) ISeatBookingCancelDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISeatBookingCancelDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISeatBookingCancelDo
	Group(cols ...field.Expr) ISeatBookingCancelDo
	Having(conds ...gen.Condition) ISeatBookingCancelDo
	Limit(limit int) ISeatBookingCancelDo
	Offset(offset int) ISeatBookingCancelDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISeatBookingCancelDo
	Unscoped() ISeatBookingCancelDo
	Create(values ...*model.SeatBookingCancel) error
	CreateInBatches(values []*model.SeatBookingCancel, batchSize int) error
	Save(values ...*model.SeatBookingCancel) error
	First() (*model.SeatBookingCancel, error)
	Take() (*model.SeatBookingCancel, error)
	Last() (*model.SeatBookingCancel, error)
	Find() ([]*model.SeatBookingCancel, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SeatBookingCancel, err error)
	FindInBatches(result *[]*model.SeatBookingCancel, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SeatBookingCancel) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISeatBookingCancelDo
	Assign(attrs ...field.AssignExpr) ISeatBookingCancelDo
	Joins(fields ...field.RelationField) ISeatBookingCancelDo
	Preload(fields ...field.RelationField) ISeatBookingCancelDo
	FirstOrInit() (*model.SeatBookingCancel, error)
	FirstOrCreate() (*model.SeatBookingCancel, error)
	FindByPage(offset int, limit int) (result []*model.SeatBookingCancel, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISeatBookingCancelDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s seatBookingCancelDo) Debug() ISeatBookingCancelDo {
	return s.withDO(s.DO.Debug())
}

func (s seatBookingCancelDo) WithContext(ctx context.Context) ISeatBookingCancelDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s seatBookingCancelDo) ReadDB() ISeatBookingCancelDo {
	return s.Clauses(dbresolver.Read)
}

func (s seatBookingCancelDo) WriteDB() ISeatBookingCancelDo {
	return s.Clauses(dbresolver.Write)
}

func (s seatBookingCancelDo) Session(config *gorm.Session) ISeatBookingCancelDo {
	return s.withDO(s.DO.Session(config))
}

func (s seatBookingCancelDo) Clauses(conds ...clause.Expression) ISeatBookingCancelDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s seatBookingCancelDo) Returning(value interface{}, columns ...string) ISeatBookingCancelDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s seatBookingCancelDo) Not(conds ...gen.Condition) ISeatBookingCancelDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s seatBookingCancelDo) Or(conds ...gen.Condition) ISeatBookingCancelDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s seatBookingCancelDo) Select(conds ...field.Expr) ISeatBookingCancelDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s seatBookingCancelDo) Where(conds ...gen.Condition) ISeatBookingCancelDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s seatBookingCancelDo) Order(conds ...field.Expr) ISeatBookingCancelDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s seatBookingCancelDo) Distinct(cols ...field.Expr) ISeatBookingCancelDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s seatBookingCancelDo) Omit(cols ...field.Expr) ISeatBookingCancelDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s seatBookingCancelDo) Join(table schema.Tabler, on ...field.Expr) ISeatBookingCancelDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s seatBookingCancelDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISeatBookingCancelDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s seatBookingCancelDo) RightJoin(table schema.Tabler, on ...field.Expr) ISeatBookingCancelDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s seatBookingCancelDo) Group(cols ...field.Expr) ISeatBookingCancelDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s seatBookingCancelDo) Having(conds ...gen.Condition) ISeatBookingCancelDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s seatBookingCancelDo) Limit(limit int) ISeatBookingCancelDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s seatBookingCancelDo) Offset(offset int) ISeatBookingCancelDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s seatBookingCancelDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISeatBookingCancelDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s seatBookingCancelDo) Unscoped() ISeatBookingCancelDo {
	return s.withDO(s.DO.Unscoped())
}

func (s seatBookingCancelDo) Create(values ...*model.SeatBookingCancel) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s seatBookingCancelDo) CreateInBatches(values []*model.SeatBookingCancel, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s seatBookingCancelDo) Save(values ...*model.SeatBookingCancel) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s seatBookingCancelDo) First() (*model.SeatBookingCancel, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatBookingCancel), nil
	}
}

func (s seatBookingCancelDo) Take() (*model.SeatBookingCancel, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatBookingCancel), nil
	}
}

func (s seatBookingCancelDo) Last() (*model.SeatBookingCancel, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatBookingCancel), nil
	}
}

func (s seatBookingCancelDo) Find() ([]*model.SeatBookingCancel, error) {
	result, err := s.DO.Find()
	return result.([]*model.SeatBookingCancel), err
}

func (s seatBookingCancelDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SeatBookingCancel, err error) {
	buf := make([]*model.SeatBookingCancel, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s seatBookingCancelDo) FindInBatches(result *[]*model.SeatBookingCancel, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s seatBookingCancelDo) Attrs(attrs ...field.AssignExpr) ISeatBookingCancelDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s seatBookingCancelDo) Assign(attrs ...field.AssignExpr) ISeatBookingCancelDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s seatBookingCancelDo) Joins(fields ...field.RelationField) ISeatBookingCancelDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s seatBookingCancelDo) Preload(fields ...field.RelationField) ISeatBookingCancelDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s seatBookingCancelDo) FirstOrInit() (*model.SeatBookingCancel, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatBookingCancel), nil
	}
}

func (s seatBookingCancelDo) FirstOrCreate() (*model.SeatBookingCancel, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SeatBookingCancel), nil
	}
}

func (s seatBookingCancelDo) FindByPage(offset int, limit int) (result []*model.SeatBookingCancel, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s seatBookingCancelDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s seatBookingCancelDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s seatBookingCancelDo) Delete(models ...*model.SeatBookingCancel) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *seatBookingCancelDo) withDO(do gen.Dao) *seatBookingCancelDo {
	s.DO = *do.(*gen.DO)
	return s
}
